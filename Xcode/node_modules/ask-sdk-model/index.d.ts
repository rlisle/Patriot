export declare namespace services {
    /**
     * Represents the interface between ApiClient and a Service Client.
     * @export
     * @interface ApiClientMessage
     */
    interface ApiClientMessage {
        headers: Array<{
            key: string;
            value: string;
        }>;
        body?: string;
    }
    /**
     * Represents a request sent from Service Clients to an ApiClient implementation.
     * @export
     * @interface ApiClientRequest
     * @extends {ApiClientMessage}
     */
    interface ApiClientRequest extends ApiClientMessage {
        url: string;
        method: string;
    }
    /**
     * Represents a response returned by ApiClient implementation to a Service Client.
     * @export
     * @interface ApiClientResponse
     * @extends {ApiClientMessage}
     */
    interface ApiClientResponse extends ApiClientMessage {
        /**
         * Result code of the attempt to satisfy the request. Normally this
         * corresponds to the HTTP status code returned by the server.
         */
        statusCode: number;
    }
    /**
     * Represents a response with parsed body.
     * @export
     * @interface ApiResponse
     */
    interface ApiResponse {
        headers: Array<{
            key: string;
            value: string;
        }>;
        body?: any;
        statusCode: number;
    }
    /**
     * Represents a basic contract for API request execution
     * @export
     * @interface ApiClient
     */
    interface ApiClient {
        /**
         * Dispatches a request to an API endpoint described in the request.
         * An ApiClient is expected to resolve the Promise in the case an API returns a non-200 HTTP
         * status code. The responsibility of translating a particular response code to an error lies with the
         * caller to invoke.
         * @param {ApiClientRequest} request request to dispatch to the ApiClient
         * @returns {Promise<ApiClientResponse>} Response from the ApiClient
         * @memberof ApiClient
         */
        invoke(request: ApiClientRequest): Promise<ApiClientResponse>;
    }
    /**
     * Represents an interface that provides API configuration options needed by service clients.
     * @interface ApiConfiguration
     */
    interface ApiConfiguration {
        /**
         * Configured ApiClient implementation
         */
        apiClient: ApiClient;
        /**
         * Authorization value to be used on any calls of the service client instance
         */
        authorizationValue: string;
        /**
         * Endpoint to hit by the service client instance
         */
        apiEndpoint: string;
    }
    /**
     * Class to be used as the base class for the generated service clients.
     */
    abstract class BaseServiceClient {
        private static isCodeSuccessful;
        private static buildUrl;
        private static interpolateParams;
        private static buildQueryString;
        /**
         * ApiConfiguration instance to provide dependencies for this service client
         */
        protected apiConfiguration: ApiConfiguration;
        private requestInterceptors;
        private responseInterceptors;
        /**
         * Creates new instance of the BaseServiceClient
         * @param {ApiConfiguration} apiConfiguration configuration parameter to provide dependencies to service client instance
         */
        protected constructor(apiConfiguration: ApiConfiguration);
        /**
         * Sets array of functions that is going to be executed before the request is send
         * @param {Function} requestInterceptor request interceptor function
         * @returns {BaseServiceClient}
         */
        withRequestInterceptors(...requestInterceptors: Array<(request: ApiClientRequest) => void | Promise<void>>): BaseServiceClient;
        /**
         * Sets array of functions that is going to be executed after the request is send
         * @param {Function} responseInterceptor response interceptor function
         * @returns {BaseServiceClient}
         */
        withResponseInterceptors(...responseInterceptors: Array<(response: ApiClientResponse) => void | Promise<void>>): BaseServiceClient;
        /**
         * Invocation wrapper to implement service operations in generated classes
         * @param method HTTP method, such as 'POST', 'GET', 'DELETE', etc.
         * @param endpoint base API url
         * @param path the path pattern with possible placeholders for path parameters in form {paramName}
         * @param pathParams path parameters collection
         * @param queryParams query parameters collection
         * @param headerParams headers collection
         * @param bodyParam if body parameter is present it is provided here, otherwise null or undefined
         * @param errors maps recognized status codes to messages
         * @param nonJsonBody if the body is in JSON format
         */
        protected invoke(method: string, endpoint: string, path: string, pathParams: Map<string, string>, queryParams: Array<{
            key: string;
            value: string;
        }>, headerParams: Array<{
            key: string;
            value: string;
        }>, bodyParam: any, errors: Map<number, string>, nonJsonBody?: boolean): Promise<any>;
    }
    /**
     * Represents a Login With Amazon(LWA) access token
     */
    interface AccessToken {
        token: string;
        expiry: Number;
    }
    /**
     * Represents a request for retrieving a Login With Amazon(LWA) access token
     */
    interface AccessTokenRequest {
        clientId: string;
        clientSecret: string;
        scope?: string;
        refreshToken?: string;
    }
    /**
     * Represents a response returned by LWA containing a Login With Amazon(LWA) access token
     */
    interface AccessTokenResponse {
        access_token: string;
        expires_in: number;
        scope: string;
        token_type: string;
    }
    /**
     * Represents the authentication configuration for a client ID and client secret
     */
    interface AuthenticationConfiguration {
        clientId: string;
        clientSecret: string;
        refreshToken?: string;
        authEndpoint?: string;
    }
    /**
     * Class to be used to call Amazon LWA to retrieve access tokens.
     */
    class LwaServiceClient extends BaseServiceClient {
        protected static EXPIRY_OFFSET_MILLIS: number;
        protected static REFRESH_ACCESS_TOKEN: string;
        protected static CLIENT_CREDENTIALS_GRANT_TYPE: string;
        protected static LWA_CREDENTIALS_GRANT_TYPE: string;
        protected static AUTH_ENDPOINT: string;
        protected authenticationConfiguration: AuthenticationConfiguration;
        protected tokenStore: {
            [cacheKey: string]: AccessToken;
        };
        protected grantType: string;
        constructor(options: {
            apiConfiguration: ApiConfiguration;
            authenticationConfiguration: AuthenticationConfiguration;
            grantType?: string;
        });
        getAccessTokenForScope(scope: string): Promise<string>;
        getAccessToken(scope?: string): Promise<string>;
        protected generateAccessToken(accessTokenRequest: AccessTokenRequest): Promise<AccessTokenResponse>;
    }
}
/**
 * function creating an AskSdk user agent.
 * @param packageVersion
 * @param customUserAgent
 */
export declare function createUserAgent(packageVersion: string, customUserAgent: string): string;
/**
 * An object containing an application ID. This is used to verify that the request was intended for your service.
 * @interface
 */
export interface Application {
    'applicationId': string;
}
/**
 * Describes the type of the Cause.
 * @interface
 */
export declare type Cause = ConnectionCompleted;
/**
 *
 * @interface
 */
export interface Context {
    'System': interfaces.system.SystemState;
    'Alexa.Presentation.APL'?: interfaces.alexa.presentation.apl.RenderedDocumentState;
    'AudioPlayer'?: interfaces.audioplayer.AudioPlayerState;
    'Automotive'?: interfaces.automotive.AutomotiveState;
    'Display'?: interfaces.display.DisplayState;
    'Geolocation'?: interfaces.geolocation.GeolocationState;
    'Viewport'?: interfaces.viewport.ViewportState;
    'Viewports'?: Array<interfaces.viewport.TypedViewportState>;
    'Extensions'?: interfaces.alexa.extension.ExtensionsState;
}
/**
 * An object providing information about the device used to send the request. The device object contains both deviceId and supportedInterfaces properties. The deviceId property uniquely identifies the device. The supportedInterfaces property lists each interface that the device supports. For example, if supportedInterfaces includes AudioPlayer {}, then you know that the device supports streaming audio using the AudioPlayer interface.
 * @interface
 */
export interface Device {
    'deviceId': string;
    'supportedInterfaces': SupportedInterfaces;
}
/**
 * Enumeration indicating the status of the multi-turn dialog. This property is included if the skill meets the requirements to use the Dialog directives. Note that COMPLETED is only possible when you use the Dialog.Delegate directive. If you use intent confirmation, dialogState is considered COMPLETED if the user denies the entire intent (for instance, by answering “no” when asked the confirmation prompt). Be sure to also check the confirmationStatus property on the Intent object before fulfilling the user’s request.
 * @enum
 */
export declare type DialogState = 'STARTED' | 'IN_PROGRESS' | 'COMPLETED';
/**
 *
 * @interface
 */
export declare type Directive = interfaces.customInterfaceController.StopEventHandlerDirective | interfaces.navigation.assistance.AnnounceRoadRegulation | interfaces.connections.SendRequestDirective | dialog.DynamicEntitiesDirective | interfaces.customInterfaceController.StartEventHandlerDirective | interfaces.gadgetController.SetLightDirective | interfaces.alexa.presentation.apl.SendIndexListDataDirective | dialog.DelegateDirective | dialog.ConfirmIntentDirective | interfaces.customInterfaceController.SendDirectiveDirective | interfaces.alexa.presentation.html.HandleMessageDirective | interfaces.alexa.presentation.apla.RenderDocumentDirective | dialog.ElicitSlotDirective | interfaces.alexa.presentation.html.StartDirective | interfaces.audioplayer.StopDirective | dialog.ConfirmSlotDirective | interfaces.audioplayer.PlayDirective | interfaces.alexa.presentation.apl.ExecuteCommandsDirective | interfaces.display.RenderTemplateDirective | dialog.DelegateRequestDirective | interfaces.display.HintDirective | interfaces.connections.V1.StartConnectionDirective | interfaces.alexa.presentation.aplt.RenderDocumentDirective | interfaces.gameEngine.StartInputHandlerDirective | interfaces.videoapp.LaunchDirective | interfaces.alexa.presentation.aplt.ExecuteCommandsDirective | interfaces.gameEngine.StopInputHandlerDirective | interfaces.tasks.CompleteTaskDirective | interfaces.alexa.presentation.apl.RenderDocumentDirective | interfaces.connections.SendResponseDirective | interfaces.audioplayer.ClearQueueDirective | interfaces.alexa.presentation.apl.UpdateIndexListDataDirective;
/**
 * An object that represents what the user wants.
 * @interface
 */
export interface Intent {
    'name': string;
    'slots'?: {
        [key: string]: Slot;
    };
    'confirmationStatus': IntentConfirmationStatus;
}
/**
 * Indication of whether an intent or slot has been explicitly confirmed or denied by the user, or neither.
 * @enum
 */
export declare type IntentConfirmationStatus = 'NONE' | 'DENIED' | 'CONFIRMED';
/**
 * This denotes the status of the permission scope.
 * @enum
 */
export declare type PermissionStatus = 'GRANTED' | 'DENIED';
/**
 * Contains a consentToken allowing the skill access to information that the customer has consented to provide, such as address information. Note that the consentToken is deprecated. Use the apiAccessToken available in the context object to determine the user’s permissions.
 * @interface
 */
export interface Permissions {
    'consentToken'?: string;
    'scopes'?: {
        [key: string]: Scope;
    };
}
/**
 * An object that describes the user (person) who is making the request.
 * @interface
 */
export interface Person {
    'personId'?: string;
    'accessToken'?: string;
}
/**
 * A request object that provides the details of the user’s request. The request body contains the parameters necessary for the service to perform its logic and generate a response.
 * @interface
 */
export declare type Request = events.skillevents.SkillEnabledRequest | services.listManagement.ListUpdatedEventRequest | interfaces.alexa.presentation.apl.UserEvent | events.skillevents.SkillDisabledRequest | services.listManagement.ListItemsCreatedEventRequest | SessionResumedRequest | SessionEndedRequest | interfaces.alexa.presentation.apl.LoadIndexListDataEvent | interfaces.audioplayer.PlaybackFailedRequest | canfulfill.CanFulfillIntentRequest | interfaces.customInterfaceController.ExpiredRequest | interfaces.alexa.presentation.html.MessageRequest | LaunchRequest | authorization.AuthorizationGrantRequest | services.reminderManagement.ReminderCreatedEventRequest | interfaces.alexa.presentation.aplt.UserEvent | services.listManagement.ListItemsUpdatedEventRequest | services.listManagement.ListCreatedEventRequest | interfaces.audioplayer.PlaybackStartedRequest | interfaces.audioplayer.PlaybackNearlyFinishedRequest | interfaces.customInterfaceController.EventsReceivedRequest | services.reminderManagement.ReminderStatusChangedEventRequest | services.listManagement.ListItemsDeletedEventRequest | services.reminderManagement.ReminderDeletedEventRequest | interfaces.connections.ConnectionsResponse | services.listManagement.ListDeletedEventRequest | interfaces.gameEngine.InputHandlerEventRequest | interfaces.playbackcontroller.PauseCommandIssuedRequest | interfaces.playbackcontroller.PlayCommandIssuedRequest | interfaces.audioplayer.PlaybackFinishedRequest | events.skillevents.ProactiveSubscriptionChangedRequest | interfaces.display.ElementSelectedRequest | events.skillevents.PermissionChangedRequest | services.reminderManagement.ReminderUpdatedEventRequest | interfaces.alexa.presentation.apl.RuntimeErrorEvent | interfaces.alexa.presentation.html.RuntimeErrorRequest | dialog.InputRequest | IntentRequest | interfaces.conversations.APIInvocationRequest | services.reminderManagement.ReminderStartedEventRequest | interfaces.audioplayer.PlaybackStoppedRequest | interfaces.playbackcontroller.PreviousCommandIssuedRequest | events.skillevents.AccountLinkedRequest | interfaces.messaging.MessageReceivedRequest | interfaces.connections.ConnectionsRequest | interfaces.system.ExceptionEncounteredRequest | events.skillevents.PermissionAcceptedRequest | interfaces.playbackcontroller.NextCommandIssuedRequest | interfaces.alexa.presentation.apla.RuntimeErrorEvent;
/**
 * Request wrapper for all requests sent to your Skill.
 * @interface
 */
export interface RequestEnvelope {
    'version': string;
    'session'?: Session;
    'context': Context;
    'request': Request;
}
/**
 *
 * @interface
 */
export interface Response {
    'outputSpeech'?: ui.OutputSpeech;
    'card'?: ui.Card;
    'reprompt'?: ui.Reprompt;
    'directives'?: Array<Directive>;
    'apiResponse'?: any;
    'shouldEndSession'?: boolean;
    'canFulfillIntent'?: canfulfill.CanFulfillIntent;
}
/**
 *
 * @interface
 */
export interface ResponseEnvelope {
    'version': string;
    'sessionAttributes'?: {
        [key: string]: any;
    };
    'userAgent'?: string;
    'response': Response;
}
/**
 * This is the value of LoginWithAmazon(LWA) consent scope. This object is used as in the key-value pairs that are provided in user.permissions.scopes object
 * @interface
 */
export interface Scope {
    'status'?: PermissionStatus;
}
/**
 * Represents a single execution of the alexa service
 * @interface
 */
export interface Session {
    'new': boolean;
    'sessionId': string;
    'user': User;
    'attributes'?: {
        [key: string]: any;
    };
    'application': Application;
}
/**
 * An error object providing more information about the error that occurred.
 * @interface
 */
export interface SessionEndedError {
    'type': SessionEndedErrorType;
    'message': string;
}
/**
 * A string indicating the type of error that occurred.
 * @enum
 */
export declare type SessionEndedErrorType = 'INVALID_RESPONSE' | 'DEVICE_COMMUNICATION_ERROR' | 'INTERNAL_SERVICE_ERROR' | 'ENDPOINT_TIMEOUT';
/**
 * The reason why session ended when not initiated from the Skill itself.
 * @enum
 */
export declare type SessionEndedReason = 'USER_INITIATED' | 'ERROR' | 'EXCEEDED_MAX_REPROMPTS';
/**
 *
 * @interface
 */
export interface Slot {
    'name': string;
    'value'?: string;
    'confirmationStatus': SlotConfirmationStatus;
    'resolutions'?: slu.entityresolution.Resolutions;
    'slotValue'?: SlotValue;
}
/**
 * An enumeration indicating whether the user has explicitly confirmed or denied the value of this slot.
 * @enum
 */
export declare type SlotConfirmationStatus = 'NONE' | 'DENIED' | 'CONFIRMED';
/**
 * Object representing the value captured in the slot.
 * @interface
 */
export declare type SlotValue = ListSlotValue | SimpleSlotValue;
/**
 * Status indicates a high level understanding of the result of an execution.
 * @interface
 */
export interface Status {
    'code': string;
    'message': string;
}
/**
 * An object listing each interface that the device supports. For example, if supportedInterfaces includes AudioPlayer {}, then you know that the device supports streaming audio using the AudioPlayer interface.
 * @interface
 */
export interface SupportedInterfaces {
    'Alexa.Presentation.APL'?: interfaces.alexa.presentation.apl.AlexaPresentationAplInterface;
    'Alexa.Presentation.APLT'?: interfaces.alexa.presentation.aplt.AlexaPresentationApltInterface;
    'Alexa.Presentation.HTML'?: interfaces.alexa.presentation.html.AlexaPresentationHtmlInterface;
    'AudioPlayer'?: interfaces.audioplayer.AudioPlayerInterface;
    'Display'?: interfaces.display.DisplayInterface;
    'VideoApp'?: interfaces.videoapp.VideoAppInterface;
    'Geolocation'?: interfaces.geolocation.GeolocationInterface;
    'Navigation'?: interfaces.navigation.NavigationInterface;
}
/**
 * This object encapsulates a specific functionality.
 * @interface
 */
export interface Task {
    'name': string;
    'version': string;
    'input'?: any;
}
/**
 * An object that describes the Amazon account for which the skill is enabled.
 * @interface
 */
export interface User {
    'userId': string;
    'accessToken'?: string;
    'permissions'?: Permissions;
}
export declare namespace authorization {
    /**
     * Authorization grant body.
     * @interface
     */
    interface AuthorizationGrantBody {
        'grant': authorization.Grant;
    }
}
export declare namespace authorization {
    /**
     * Information that identifies a user in Amazon Alexa systems.
     * @interface
     */
    interface Grant {
        'type': authorization.GrantType;
        'code': string;
    }
}
export declare namespace authorization {
    /**
     * One of the grant types supported.
     * @enum
     */
    type GrantType = 'OAuth2.AuthorizationCode';
}
export declare namespace canfulfill {
    /**
     * CanFulfillIntent represents the response to canFulfillIntentRequest includes the details about whether the skill can understand and fulfill the intent request with detected slots.
     * @interface
     */
    interface CanFulfillIntent {
        'canFulfill': canfulfill.CanFulfillIntentValues;
        'slots'?: {
            [key: string]: canfulfill.CanFulfillSlot;
        };
    }
}
export declare namespace canfulfill {
    /**
     * Overall if skill can understand and fulfill the intent with detected slots. Respond YES when skill understands all slots, can fulfill all slots, and can fulfill the request in its entirety. Respond NO when skill either cannot understand the intent, cannot understand all the slots, or cannot fulfill all the slots. Respond MAYBE when skill can understand the intent, can partially or fully understand the slots, and can partially or fully fulfill the slots. The only cases where should respond MAYBE is when skill partially understand the request and can potentially complete the request if skill get more data, either through callbacks or through a multi-turn conversation with the user.
     * @enum
     */
    type CanFulfillIntentValues = 'YES' | 'NO' | 'MAYBE';
}
export declare namespace canfulfill {
    /**
     * This represents skill's capability to understand and fulfill each detected slot.
     * @interface
     */
    interface CanFulfillSlot {
        'canUnderstand': canfulfill.CanUnderstandSlotValues;
        'canFulfill'?: canfulfill.CanFulfillSlotValues;
    }
}
export declare namespace canfulfill {
    /**
     * This field indicates whether skill can fulfill relevant action for the slot, that has been partially or fully understood. The definition of fulfilling the slot is dependent on skill and skill is required to have logic in place to determine whether a slot value can be fulfilled in the context of skill or not. Return YES if Skill can certainly fulfill the relevant action for this slot value. Return NO if skill cannot fulfill the relevant action for this slot value. For specific recommendations to set the value refer to the developer docs for more details.
     * @enum
     */
    type CanFulfillSlotValues = 'YES' | 'NO';
}
export declare namespace canfulfill {
    /**
     * This field indicates whether skill has understood the slot value. In most typical cases, skills will do some form of entity resolution by looking up a catalog or list to determine whether they recognize the slot or not. Return YES if skill have a perfect match or high confidence match (for eg. synonyms) with catalog or list maintained by skill. Return NO if skill cannot understand or recognize the slot value. Return MAYBE if skill have partial confidence or partial match. This will be true when the slot value doesn’t exist as is, in the catalog, but a variation or a fuzzy match may exist. For specific recommendations to set the value refer to the developer docs for more details.
     * @enum
     */
    type CanUnderstandSlotValues = 'YES' | 'NO' | 'MAYBE';
}
export declare namespace dialog {
    /**
     * The delegation period.
     * @interface
     */
    interface DelegationPeriod {
        'until'?: dialog.DelegationPeriodUntil;
    }
}
export declare namespace dialog {
    /**
     * The end of the specified delegation period.   * EXPLICIT_RETURN - delegation lasts until the targeted dialog manager returns a delegate with a new target.   * NEXT_TURN - delegation lasts until the next turn, which resumes with the current focused dialog manager.
     * @enum
     */
    type DelegationPeriodUntil = 'EXPLICIT_RETURN' | 'NEXT_TURN';
}
export declare namespace dialog {
    /**
     * Structured input data to send to a dialog manager. Currently, this is an Alexa Conversations input instance.
     * @interface
     */
    interface Input {
        'name': string;
        'slots'?: {
            [key: string]: Slot;
        };
    }
}
export declare namespace dialog {
    /**
     * The updated request to delegate. Null will delegate the current request.
     * @interface
     */
    type UpdatedRequest = dialog.UpdatedInputRequest | dialog.UpdatedIntentRequest;
}
export declare namespace dynamicEndpoints {
    /**
     * Base response type.
     * @interface
     */
    type BaseResponse = dynamicEndpoints.FailureResponse | dynamicEndpoints.SuccessResponse;
}
export declare namespace dynamicEndpoints {
    /**
     * Request from a Dynamic endpoint connection.
     * @interface
     */
    interface Request {
        'version': string;
        'type': string;
        'requestId': string;
        'requestPayload': string;
    }
}
export declare namespace er.dynamic {
    /**
     * Represents an entity that the skill wants to store. An entity has an optional Id and the value and the synonyms for the entity
     * @interface
     */
    interface Entity {
        'id'?: string;
        'name': er.dynamic.EntityValueAndSynonyms;
    }
}
export declare namespace er.dynamic {
    /**
     * Represents an array of entities of a particular type.
     * @interface
     */
    interface EntityListItem {
        'name': string;
        'values': Array<er.dynamic.Entity>;
    }
}
export declare namespace er.dynamic {
    /**
     * A container object with value and synomyms for the entity
     * @interface
     */
    interface EntityValueAndSynonyms {
        'value': string;
        'synonyms'?: Array<string>;
    }
}
export declare namespace er.dynamic {
    /**
     * Replace the existing dynamic entities or clear them from the catalog
     * @enum
     */
    type UpdateBehavior = 'REPLACE' | 'CLEAR';
}
export declare namespace events.skillevents {
    /**
     *
     * @interface
     */
    interface AccountLinkedBody {
        'accessToken'?: string;
    }
}
export declare namespace events.skillevents {
    /**
     *
     * @interface
     */
    interface Permission {
        'scope'?: string;
    }
}
export declare namespace events.skillevents {
    /**
     *
     * @interface
     */
    interface PermissionBody {
        'acceptedPermissions'?: Array<events.skillevents.Permission>;
        'acceptedPersonPermissions'?: Array<events.skillevents.Permission>;
    }
}
export declare namespace events.skillevents {
    /**
     *
     * @interface
     */
    interface ProactiveSubscriptionChangedBody {
        'subscriptions'?: Array<events.skillevents.ProactiveSubscriptionEvent>;
    }
}
export declare namespace events.skillevents {
    /**
     *
     * @interface
     */
    interface ProactiveSubscriptionEvent {
        'eventName'?: string;
    }
}
export declare namespace interfaces.alexa.comms.messagingcontroller {
    /**
     * A map whose key is the new status and value is the message ID list. The status of the messages whose IDs are in the list will be updated to the new status from the key.
     * @interface
     */
    interface StatusMap {
        'read'?: Array<string>;
        'deleted'?: Array<string>;
    }
}
export declare namespace interfaces.alexa.extension {
    /**
     * This object describes an extension that skill can request at runtime.
     * @interface
     */
    interface AvailableExtension {
    }
}
export declare namespace interfaces.alexa.extension {
    /**
     *
     * @interface
     */
    interface ExtensionsState {
        'available': {
            [key: string]: interfaces.alexa.extension.AvailableExtension;
        };
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     *
     * @interface
     */
    interface AlexaPresentationAplInterface {
        'runtime'?: interfaces.alexa.presentation.apl.Runtime;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The alignment of the item after scrolling. Defaults to visible.
     * @enum
     */
    type Align = 'center' | 'first' | 'last' | 'visible';
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * How repeated animations will play.
     * @enum
     */
    type AnimateItemRepeatMode = 'restart' | 'reverse';
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     *
     * @interface
     */
    type AnimatedProperty = interfaces.alexa.presentation.apl.AnimatedOpacityProperty | interfaces.alexa.presentation.apl.AnimatedTransformProperty;
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The audio track to play on. Defaults to “foreground”
     * @enum
     */
    type AudioTrack = 'foreground';
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * A message that can change the visual or audio presentation of the content on the screen.
     * @interface
     */
    type Command = interfaces.alexa.presentation.apl.SetPageCommand | interfaces.alexa.presentation.apl.ControlMediaCommand | interfaces.alexa.presentation.apl.FinishCommand | interfaces.alexa.presentation.apl.AutoPageCommand | interfaces.alexa.presentation.apl.PlayMediaCommand | interfaces.alexa.presentation.apl.ScrollCommand | interfaces.alexa.presentation.apl.IdleCommand | interfaces.alexa.presentation.apl.AnimateItemCommand | interfaces.alexa.presentation.apl.SendEventCommand | interfaces.alexa.presentation.apl.SpeakListCommand | interfaces.alexa.presentation.apl.SelectCommand | interfaces.alexa.presentation.apl.SequentialCommand | interfaces.alexa.presentation.apl.SetStateCommand | interfaces.alexa.presentation.apl.SpeakItemCommand | interfaces.alexa.presentation.apl.ParallelCommand | interfaces.alexa.presentation.apl.OpenUrlCommand | interfaces.alexa.presentation.apl.ClearFocusCommand | interfaces.alexa.presentation.apl.ScrollToIndexCommand | interfaces.alexa.presentation.apl.SetValueCommand | interfaces.alexa.presentation.apl.SetFocusCommand | interfaces.alexa.presentation.apl.ScrollToComponentCommand;
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The entity context data which was attached to an element.
     * @interface
     */
    interface ComponentEntity {
        'type'?: string;
        'value'?: string;
        'id'?: string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Component state.
     * @enum
     */
    type ComponentState = 'checked' | 'disabled' | 'focused';
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Definition of a visible APL element shown on screen.
     * @interface
     */
    interface ComponentVisibleOnScreen {
        'children'?: Array<interfaces.alexa.presentation.apl.ComponentVisibleOnScreen>;
        'entities'?: Array<interfaces.alexa.presentation.apl.ComponentEntity>;
        'id': string;
        'position': string;
        'tags': interfaces.alexa.presentation.apl.ComponentVisibleOnScreenTags;
        'transform'?: Array<number>;
        'type': string;
        'uid': string;
        'visibility'?: number;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * An element in a scrolling list
     * @interface
     */
    interface ComponentVisibleOnScreenListItemTag {
        'index'?: number;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * An ordered list of items
     * @interface
     */
    interface ComponentVisibleOnScreenListTag {
        'itemCount'?: number;
        'lowestIndexSeen'?: number;
        'highestIndexSeen'?: number;
        'lowestOrdinalSeen'?: number;
        'highestOrdinalSeen'?: number;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Media player
     * @interface
     */
    interface ComponentVisibleOnScreenMediaTag {
        'positionInMilliseconds'?: number;
        'state'?: interfaces.alexa.presentation.apl.ComponentVisibleOnScreenMediaTagStateEnum;
        'allowAdjustSeekPositionForward'?: boolean;
        'allowAdjustSeekPositionBackwards'?: boolean;
        'allowNext'?: boolean;
        'allowPrevious'?: boolean;
        'entities'?: Array<interfaces.alexa.presentation.apl.ComponentEntity>;
        'url'?: string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Media player stage posible states
     * @enum
     */
    type ComponentVisibleOnScreenMediaTagStateEnum = 'idle' | 'playing' | 'paused';
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * A collection of items that are displayed one at a time.
     * @interface
     */
    interface ComponentVisibleOnScreenPagerTag {
        'index'?: number;
        'pageCount'?: number;
        'allowForward'?: boolean;
        'allowBackwards'?: boolean;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * A scrollable region.
     * @interface
     */
    interface ComponentVisibleOnScreenScrollableTag {
        'direction'?: interfaces.alexa.presentation.apl.ComponentVisibleOnScreenScrollableTagDirectionEnum;
        'allowForward'?: boolean;
        'allowBackward'?: boolean;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Scrolling direction
     * @enum
     */
    type ComponentVisibleOnScreenScrollableTagDirectionEnum = 'horizontal' | 'vertical';
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The tags which were attached to an element.
     * @interface
     */
    interface ComponentVisibleOnScreenTags {
        'checked'?: boolean;
        'clickable'?: boolean;
        'disabled'?: boolean;
        'focused'?: boolean;
        'list'?: interfaces.alexa.presentation.apl.ComponentVisibleOnScreenListTag;
        'listItem'?: interfaces.alexa.presentation.apl.ComponentVisibleOnScreenListItemTag;
        'media'?: interfaces.alexa.presentation.apl.ComponentVisibleOnScreenMediaTag;
        'ordinal'?: number;
        'pager'?: interfaces.alexa.presentation.apl.ComponentVisibleOnScreenPagerTag;
        'scrollable'?: interfaces.alexa.presentation.apl.ComponentVisibleOnScreenScrollableTag;
        'spoken'?: boolean;
        'viewport'?: interfaces.alexa.presentation.apl.ComponentVisibleOnScreenViewportTag;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The entire screen in which a document is rendered.
     * @interface
     */
    interface ComponentVisibleOnScreenViewportTag {
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * How highlighting is applied: on a line-by-line basis, or to the entire block. Defaults to block.
     * @enum
     */
    type HighlightMode = 'block' | 'line';
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The reason for the failure.
     * @enum
     */
    type ListRuntimeErrorReason = 'INVALID_PRESENTATION_TOKEN' | 'INVALID_LIST_ID' | 'INVALID_DATASOURCE' | 'INVALID_OPERATION' | 'MISSING_LIST_VERSION' | 'DUPLICATE_LIST_VERSION' | 'LIST_INDEX_OUT_OF_RANGE' | 'MISSING_LIST_VERSION_IN_SEND_DATA' | 'LOAD_TIMEOUT' | 'INCONSISTENT_LIST_ID' | 'INCONSISTENT_PAGE_TOKEN' | 'INCONSISTENT_PAGE_ITEMS' | 'DUPLICATE_PAGE_TOKEN' | 'OCCUPIED_LIST_INDEX' | 'LOAD_INDEX_OUT_OF_RANGE' | 'INCONSISTENT_RANGE' | 'MISSING_LIST_ITEMS' | 'INTERNAL_ERROR';
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The command enumerated value is the operation that should be performed on the media player.
     * @enum
     */
    type MediaCommandType = 'play' | 'pause' | 'next' | 'previous' | 'rewind' | 'seek' | 'setTrack';
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Whether the value is a relative or absolute offset. Defaults to absolute.
     * @enum
     */
    type Position = 'absolute' | 'relative';
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Provides context for any APL content shown on screen.
     * @interface
     */
    interface RenderedDocumentState {
        'token': string;
        'version'?: string;
        'componentsVisibleOnScreen'?: Array<interfaces.alexa.presentation.apl.ComponentVisibleOnScreen>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Contains the runtime information for the interface.
     * @interface
     */
    interface Runtime {
        'maxVersion'?: string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * A description of an error in APL functionality.
     * @interface
     */
    type RuntimeError = interfaces.alexa.presentation.apl.ListRuntimeError;
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Transform property to apply to a component.
     * @interface
     */
    type TransformProperty = interfaces.alexa.presentation.apl.MoveTransformProperty | interfaces.alexa.presentation.apl.ScaleTransformProperty | interfaces.alexa.presentation.apl.RotateTransformProperty | interfaces.alexa.presentation.apl.SkewTransformProperty;
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The source property holds the video clip or sequence of video clips to play.
     * @interface
     */
    interface VideoSource {
        'description'?: string;
        'duration'?: number | string;
        'url': string;
        'repeatCount'?: number | string;
        'offset'?: number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl.listoperations {
    /**
     * An operation which adds, removes or replaces item(s) defined in a dynamicIndexList.
     * @interface
     */
    type Operation = interfaces.alexa.presentation.apl.listoperations.SetItemOperation | interfaces.alexa.presentation.apl.listoperations.InsertMultipleItemsOperation | interfaces.alexa.presentation.apl.listoperations.DeleteMultipleItemsOperation | interfaces.alexa.presentation.apl.listoperations.InsertItemOperation | interfaces.alexa.presentation.apl.listoperations.DeleteItemOperation;
}
export declare namespace interfaces.alexa.presentation.apla {
    /**
     * The reason for the failure.
     * @enum
     */
    type AudioSourceErrorReason = 'UNKNOWN_ERROR' | 'INTERNAL_SERVER_ERROR' | 'NOT_FOUND_ERROR' | 'SSL_HANDSHAKE_ERROR' | 'TIMEOUT_ERROR' | 'INVALID_URI_ERROR' | 'HTTPS_ERROR';
}
export declare namespace interfaces.alexa.presentation.apla {
    /**
     * The reason for the failure.
     * @enum
     */
    type DocumentErrorReason = 'UNKNOWN_ERROR' | 'INTERNAL_SERVER_ERROR';
}
export declare namespace interfaces.alexa.presentation.apla {
    /**
     * The reason for the failure.
     * @enum
     */
    type LinkErrorReason = 'UNKNOWN_ERROR' | 'INTERNAL_SERVER_ERROR' | 'NOT_FOUND_ERROR';
}
export declare namespace interfaces.alexa.presentation.apla {
    /**
     * The reason for the failure.
     * @enum
     */
    type RenderErrorReason = 'UNKNOWN_ERROR' | 'INTERNAL_SERVER_ERROR';
}
export declare namespace interfaces.alexa.presentation.apla {
    /**
     * A description of an error in APLA functionality.
     * @interface
     */
    type RuntimeError = interfaces.alexa.presentation.apla.AudioSourceRuntimeError | interfaces.alexa.presentation.apla.RenderRuntimeError | interfaces.alexa.presentation.apla.DocumentRuntimeError | interfaces.alexa.presentation.apla.LinkRuntimeError;
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     *
     * @interface
     */
    interface AlexaPresentationApltInterface {
        'runtime'?: interfaces.alexa.presentation.aplt.Runtime;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * A message that can change the visual or audio presentation of the content on the screen.
     * @interface
     */
    type Command = interfaces.alexa.presentation.aplt.SetValueCommand | interfaces.alexa.presentation.aplt.IdleCommand | interfaces.alexa.presentation.aplt.AutoPageCommand | interfaces.alexa.presentation.aplt.ScrollCommand | interfaces.alexa.presentation.aplt.SendEventCommand | interfaces.alexa.presentation.aplt.ParallelCommand | interfaces.alexa.presentation.aplt.SetPageCommand | interfaces.alexa.presentation.aplt.SequentialCommand;
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * Whether the value is a relative or absolute offset. Defaults to absolute.
     * @enum
     */
    type Position = 'absolute' | 'relative';
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * Contains the runtime information for the interface.
     * @interface
     */
    interface Runtime {
        'maxVersion'?: string;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * Name of a supported profile on character display.
     * @enum
     */
    type TargetProfile = 'FOUR_CHARACTER_CLOCK' | 'NONE';
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     *
     * @interface
     */
    interface AlexaPresentationHtmlInterface {
        'runtime'?: interfaces.alexa.presentation.html.Runtime;
    }
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     *
     * @interface
     */
    interface Configuration {
        'timeoutInSeconds'?: number;
    }
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     * Contains the runtime information for the interface.
     * @interface
     */
    interface Runtime {
        'maxVersion': string;
    }
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     *
     * @interface
     */
    interface RuntimeError {
        'reason': interfaces.alexa.presentation.html.RuntimeErrorReason;
        'message'?: string;
        'code'?: string;
    }
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     *
     * @enum
     */
    type RuntimeErrorReason = 'HTTP_REQUEST_ERROR' | 'TIMED_OUT' | 'FILE_TYPE_NOT_SUPPORTED' | 'APPLICATION_ERROR';
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     *
     * @interface
     */
    interface StartRequest {
        'method': interfaces.alexa.presentation.html.StartRequestMethod;
        'uri'?: string;
        'headers'?: any;
    }
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     *
     * @enum
     */
    type StartRequestMethod = 'GET';
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     * Properties for performing text to speech transformations. These are the same properties that [APL transformers](https://developer.amazon.com/docs/alexa-presentation-language/apl-data-source.html#transformer-properties-and-conversion-rules) use.
     * @interface
     */
    interface Transformer {
        'transformer': interfaces.alexa.presentation.html.TransformerType;
        'inputPath': string;
        'outputName'?: string;
    }
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     *
     * @enum
     */
    type TransformerType = 'ssmlToSpeech' | 'textToSpeech' | 'textToHint' | 'ssmlToText';
}
export declare namespace interfaces.amazonpay.model.request {
    /**
     *
     * @interface
     */
    type BaseAmazonPayEntity = interfaces.amazonpay.model.request.SellerBillingAgreementAttributes | interfaces.amazonpay.model.request.Price | interfaces.amazonpay.request.ChargeAmazonPayRequest | interfaces.amazonpay.model.request.BillingAgreementAttributes | interfaces.amazonpay.model.request.SellerOrderAttributes | interfaces.amazonpay.model.request.ProviderAttributes | interfaces.amazonpay.model.request.AuthorizeAttributes | interfaces.amazonpay.request.SetupAmazonPayRequest | interfaces.amazonpay.model.request.ProviderCredit;
}
export declare namespace interfaces.amazonpay.model.request {
    /**
     * * This is used to specify applicable billing agreement type. * CustomerInitiatedTransaction – customer is present at the time of processing payment for the order. * MerchantInitiatedTransaction – customer is not present at the time of processing payment for the order.
     * @enum
     */
    type BillingAgreementType = 'CustomerInitiatedTransaction' | 'MerchantInitiatedTransaction';
}
export declare namespace interfaces.amazonpay.model.request {
    /**
     * * This is used to specify applicable payment action. * Authorize – you want to confirm the order and authorize a certain amount, but you do not want to capture at this time. * AuthorizeAndCapture – you want to confirm the order, authorize for the given amount, and capture the funds.
     * @enum
     */
    type PaymentAction = 'Authorize' | 'AuthorizeAndCapture';
}
export declare namespace interfaces.amazonpay.model.response {
    /**
     * Indicates if the contract is for a Live (Production) or Sandbox environment.
     * @enum
     */
    type ReleaseEnvironment = 'LIVE' | 'SANDBOX';
}
export declare namespace interfaces.amazonpay.model.response {
    /**
     * Indicates the state that the Authorization object is in. For more information see “Authorization states and reason codes” under “States and reason codes” section in Amazon Pay API Reference Guide.
     * @enum
     */
    type State = 'Pending' | 'Open' | 'Declined' | 'Closed';
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * This object encapsulates details about an Authorization object including the status, amount captured and fee charged.
     * @interface
     */
    interface AuthorizationDetails {
        'amazonAuthorizationId'?: string;
        'authorizationReferenceId'?: string;
        'sellerAuthorizationNote'?: string;
        'authorizationAmount'?: interfaces.amazonpay.model.v1.Price;
        'capturedAmount'?: interfaces.amazonpay.model.v1.Price;
        'authorizationFee'?: interfaces.amazonpay.model.v1.Price;
        'idList'?: Array<string>;
        'creationTimestamp'?: string;
        'expirationTimestamp'?: string;
        'authorizationStatus'?: interfaces.amazonpay.model.v1.AuthorizationStatus;
        'softDecline'?: boolean;
        'captureNow'?: boolean;
        'softDescriptor'?: string;
    }
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * Indicates the current status of an Authorization object, a Capture object, or a Refund object.
     * @interface
     */
    interface AuthorizationStatus {
        'state'?: interfaces.amazonpay.model.v1.State;
        'reasonCode'?: string;
        'reasonDescription'?: string;
        'lastUpdateTimestamp'?: string;
    }
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * This is an object to set the attributes specified in the AuthorizeAttributes table. See the “AuthorizationDetails” section of the Amazon Pay API reference guide for details about this object.
     * @interface
     */
    interface AuthorizeAttributes {
        'authorizationReferenceId': string;
        'authorizationAmount': interfaces.amazonpay.model.v1.Price;
        'transactionTimeout'?: number;
        'sellerAuthorizationNote'?: string;
        'softDescriptor'?: string;
    }
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * The merchant can choose to set the attributes specified in the BillingAgreementAttributes.
     * @interface
     */
    interface BillingAgreementAttributes {
        'platformId'?: string;
        'sellerNote'?: string;
        'sellerBillingAgreementAttributes'?: interfaces.amazonpay.model.v1.SellerBillingAgreementAttributes;
        'billingAgreementType'?: interfaces.amazonpay.model.v1.BillingAgreementType;
        'subscriptionAmount'?: interfaces.amazonpay.model.v1.Price;
    }
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * The result attributes from successful SetupAmazonPay call.
     * @interface
     */
    interface BillingAgreementDetails {
        'billingAgreementId': string;
        'creationTimestamp'?: string;
        'destination'?: interfaces.amazonpay.model.v1.Destination;
        'checkoutLanguage'?: string;
        'releaseEnvironment': interfaces.amazonpay.model.v1.ReleaseEnvironment;
        'billingAgreementStatus': interfaces.amazonpay.model.v1.BillingAgreementStatus;
    }
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * Indicates the current status of the billing agreement. For more information about the State and ReasonCode response elements, see Billing agreement states and reason codes - https://pay.amazon.com/us/developer/documentation/apireference/201752870
     * @enum
     */
    type BillingAgreementStatus = 'CANCELED' | 'CLOSED' | 'DRAFT' | 'OPEN' | 'SUSPENDED';
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * * This is used to specify applicable billing agreement type. * CustomerInitiatedTransaction – customer is present at the time of processing payment for the order. * MerchantInitiatedTransaction – customer is not present at the time of processing payment for the order.
     * @enum
     */
    type BillingAgreementType = 'CustomerInitiatedTransaction' | 'MerchantInitiatedTransaction';
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * Destination object containing the details of an Address.
     * @interface
     */
    interface Destination {
        'name'?: string;
        'companyName'?: string;
        'addressLine1'?: string;
        'addressLine2'?: string;
        'addressLine3'?: string;
        'city'?: string;
        'districtOrCounty'?: string;
        'stateOrRegion'?: string;
        'postalCode'?: string;
        'countryCode'?: string;
        'phone'?: string;
    }
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * * This is used to specify applicable payment action. * Authorize – you want to confirm the order and authorize a certain amount, but you do not want to capture at this time. * AuthorizeAndCapture – you want to confirm the order, authorize for the given amount, and capture the funds.
     * @enum
     */
    type PaymentAction = 'Authorize' | 'AuthorizeAndCapture';
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * This object specifies amount and currency authorized/captured.
     * @interface
     */
    interface Price {
        'amount': string;
        'currencyCode': string;
    }
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * This is required only for Ecommerce provider (Solution provider) use cases.
     * @interface
     */
    interface ProviderAttributes {
        'providerId': string;
        'providerCreditList': Array<interfaces.amazonpay.model.v1.ProviderCredit>;
    }
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     *
     * @interface
     */
    interface ProviderCredit {
        'providerId'?: string;
        'credit'?: interfaces.amazonpay.model.v1.Price;
    }
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * Indicates if the order is for a Live (Production) or Sandbox environment.
     * @enum
     */
    type ReleaseEnvironment = 'LIVE' | 'SANDBOX';
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * Provides more context about the billing agreement that is represented by this Billing Agreement object.
     * @interface
     */
    interface SellerBillingAgreementAttributes {
        'sellerBillingAgreementId'?: string;
        'storeName'?: string;
        'customInformation'?: string;
    }
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * This object includes elements shown to buyers in emails and in their transaction history. See the “SellerOrderAttributes” section of the Amazon Pay API reference guide for details about this object.
     * @interface
     */
    interface SellerOrderAttributes {
        'sellerOrderId'?: string;
        'storeName'?: string;
        'customInformation'?: string;
        'sellerNote'?: string;
    }
}
export declare namespace interfaces.amazonpay.model.v1 {
    /**
     * Indicates the state that the Authorization object, Capture object, or Refund object is in. For more information see - https://pay.amazon.com/us/developer/documentation/apireference/201752950
     * @enum
     */
    type State = 'Pending' | 'Open' | 'Declined' | 'Closed' | 'Completed';
}
export declare namespace interfaces.amazonpay.response {
    /**
     * Setup Amazon Pay Result Object. It is sent as part of the response to SetupAmazonPayRequest.
     * @interface
     */
    interface SetupAmazonPayResult {
        'billingAgreementDetails': interfaces.amazonpay.model.response.BillingAgreementDetails;
    }
}
export declare namespace interfaces.amazonpay.v1 {
    /**
     * Error response for SetupAmazonPay and ChargeAmazonPay calls.
     * @interface
     */
    interface AmazonPayErrorResponse {
        'errorCode': string;
        'errorMessage': string;
    }
}
export declare namespace interfaces.amazonpay.v1 {
    /**
     * Charge Amazon Pay Request Object
     * @interface
     */
    interface ChargeAmazonPay {
        'consentToken'?: string;
        'sellerId': string;
        'billingAgreementId': string;
        'paymentAction': interfaces.amazonpay.model.v1.PaymentAction;
        'authorizeAttributes': interfaces.amazonpay.model.v1.AuthorizeAttributes;
        'sellerOrderAttributes'?: interfaces.amazonpay.model.v1.SellerOrderAttributes;
        'providerAttributes'?: interfaces.amazonpay.model.v1.ProviderAttributes;
    }
}
export declare namespace interfaces.amazonpay.v1 {
    /**
     * Charge Amazon Pay Result Object. It is sent as part of the reponse to ChargeAmazonPay request.
     * @interface
     */
    interface ChargeAmazonPayResult {
        'amazonOrderReferenceId': string;
        'authorizationDetails': interfaces.amazonpay.model.v1.AuthorizationDetails;
    }
}
export declare namespace interfaces.amazonpay.v1 {
    /**
     * Setup Amazon Pay Request Object
     * @interface
     */
    interface SetupAmazonPay {
        'consentToken'?: string;
        'sellerId': string;
        'countryOfEstablishment': string;
        'ledgerCurrency': string;
        'checkoutLanguage'?: string;
        'billingAgreementAttributes'?: interfaces.amazonpay.model.v1.BillingAgreementAttributes;
        'needAmazonShippingAddress'?: boolean;
        'sandboxMode'?: boolean;
        'sandboxCustomerEmailId'?: string;
    }
}
export declare namespace interfaces.amazonpay.v1 {
    /**
     * Setup Amazon Pay Result Object. It is sent as part of the reponse to SetupAmazonPay request.
     * @interface
     */
    interface SetupAmazonPayResult {
        'billingAgreementDetails': interfaces.amazonpay.model.v1.BillingAgreementDetails;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface AudioItem {
        'stream'?: interfaces.audioplayer.Stream;
        'metadata'?: interfaces.audioplayer.AudioItemMetadata;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     * Encapsulates the metadata about an AudioItem.
     * @interface
     */
    interface AudioItemMetadata {
        'title'?: string;
        'subtitle'?: string;
        'art'?: interfaces.display.Image;
        'backgroundImage'?: interfaces.display.Image;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface AudioPlayerInterface {
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface AudioPlayerState {
        'offsetInMilliseconds'?: number;
        'token'?: string;
        'playerActivity'?: interfaces.audioplayer.PlayerActivity;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface CaptionData {
        'content'?: string;
        'type'?: interfaces.audioplayer.CaptionType;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @enum
     */
    type CaptionType = 'WEBVTT';
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @enum
     */
    type ClearBehavior = 'CLEAR_ALL' | 'CLEAR_ENQUEUED';
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface CurrentPlaybackState {
        'offsetInMilliseconds'?: number;
        'playerActivity'?: interfaces.audioplayer.PlayerActivity;
        'token'?: string;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface Error {
        'message'?: string;
        'type'?: interfaces.audioplayer.ErrorType;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @enum
     */
    type ErrorType = 'MEDIA_ERROR_INTERNAL_DEVICE_ERROR' | 'MEDIA_ERROR_INTERNAL_SERVER_ERROR' | 'MEDIA_ERROR_INVALID_REQUEST' | 'MEDIA_ERROR_SERVICE_UNAVAILABLE' | 'MEDIA_ERROR_UNKNOWN';
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @enum
     */
    type PlayBehavior = 'ENQUEUE' | 'REPLACE_ALL' | 'REPLACE_ENQUEUED';
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @enum
     */
    type PlayerActivity = 'PLAYING' | 'PAUSED' | 'FINISHED' | 'BUFFER_UNDERRUN' | 'IDLE' | 'STOPPED';
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface Stream {
        'expectedPreviousToken'?: string;
        'token': string;
        'url': string;
        'offsetInMilliseconds': number;
        'captionData'?: interfaces.audioplayer.CaptionData;
    }
}
export declare namespace interfaces.automotive {
    /**
     * This object contains the automotive specific information of the device
     * @interface
     */
    interface AutomotiveState {
    }
}
export declare namespace interfaces.connections {
    /**
     * Connection Status indicates a high level understanding of the result of ConnectionsRequest.
     * @interface
     */
    interface ConnectionsStatus {
        'code': string;
        'message'?: string;
    }
}
export declare namespace interfaces.connections {
    /**
     * This defines the callback mechanism when the task is completed, i.e., whether the requester wants to be resumed after the task is fulfilled or just be notified about errors without being resumed.
     * @enum
     */
    type OnCompletion = 'RESUME_SESSION' | 'SEND_ERRORS_ONLY';
}
export declare namespace interfaces.connections.entities {
    /**
     *
     * @interface
     */
    type BaseEntity = interfaces.connections.entities.PostalAddress | interfaces.connections.entities.Restaurant;
}
export declare namespace interfaces.connections.requests {
    /**
     *
     * @interface
     */
    type BaseRequest = interfaces.connections.requests.ScheduleFoodEstablishmentReservationRequest | interfaces.connections.requests.PrintImageRequest | interfaces.connections.requests.PrintWebPageRequest | interfaces.connections.requests.PrintPDFRequest | interfaces.connections.requests.ScheduleTaxiReservationRequest;
}
export declare namespace interfaces.conversations {
    /**
     * API request object
     * @interface
     */
    interface APIRequest {
        'name'?: string;
        'arguments'?: {
            [key: string]: any;
        };
        'slots'?: {
            [key: string]: SlotValue;
        };
    }
}
export declare namespace interfaces.customInterfaceController {
    /**
     * The endpoint of a gadget.
     * @interface
     */
    interface Endpoint {
        'endpointId': string;
    }
}
export declare namespace interfaces.customInterfaceController {
    /**
     * An Event object defining a single event sent by an endpoint
     * @interface
     */
    interface Event {
        'header': interfaces.customInterfaceController.Header;
        'payload': any;
        'endpoint': interfaces.customInterfaceController.Endpoint;
    }
}
export declare namespace interfaces.customInterfaceController {
    /**
     * Defines the Jsonlogic event filter expression and its corresponding match action.  This filter is applied to all events during the event handler's duration.  Events that are rejected by the filter expression are not sent to the skill.
     * @interface
     */
    interface EventFilter {
        'filterExpression': any;
        'filterMatchAction': interfaces.customInterfaceController.FilterMatchAction;
    }
}
export declare namespace interfaces.customInterfaceController {
    /**
     * This object defines the duration of the Event Handler and the optional JSON payload that is delivered to the skill when the timer expires.
     * @interface
     */
    interface Expiration {
        'durationInMilliseconds': number;
        'expirationPayload'?: any;
    }
}
export declare namespace interfaces.customInterfaceController {
    /**
     * The behavior to be performed by the platform on a successful filter expression match.
     * @enum
     */
    type FilterMatchAction = 'SEND_AND_TERMINATE' | 'SEND';
}
export declare namespace interfaces.customInterfaceController {
    /**
     * Endpoint Event header
     * @interface
     */
    interface Header {
        'namespace': string;
        'name': string;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @enum
     */
    type BackButtonBehavior = 'HIDDEN' | 'VISIBLE';
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface DisplayInterface {
        'templateVersion'?: string;
        'markupVersion'?: string;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface DisplayState {
        'token'?: string;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    type Hint = interfaces.display.PlainTextHint;
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface Image {
        'contentDescription'?: string;
        'sources'?: Array<interfaces.display.ImageInstance>;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface ImageInstance {
        'url': string;
        'size'?: interfaces.display.ImageSize;
        'widthPixels'?: number;
        'heightPixels'?: number;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @enum
     */
    type ImageSize = 'X_SMALL' | 'SMALL' | 'MEDIUM' | 'LARGE' | 'X_LARGE';
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface ListItem {
        'token': string;
        'image'?: interfaces.display.Image;
        'textContent'?: interfaces.display.TextContent;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    type Template = interfaces.display.ListTemplate2 | interfaces.display.ListTemplate1 | interfaces.display.BodyTemplate7 | interfaces.display.BodyTemplate6 | interfaces.display.BodyTemplate3 | interfaces.display.BodyTemplate2 | interfaces.display.BodyTemplate1;
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface TextContent {
        'primaryText'?: interfaces.display.TextField;
        'secondaryText'?: interfaces.display.TextField;
        'tertiaryText'?: interfaces.display.TextField;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    type TextField = interfaces.display.RichText | interfaces.display.PlainText;
}
export declare namespace interfaces.geolocation {
    /**
     * A string representing if Alexa has access to location services running on the hostOS of device.
     * @enum
     */
    type Access = 'ENABLED' | 'DISABLED' | 'UNKNOWN';
}
export declare namespace interfaces.geolocation {
    /**
     * An object containing the altitude information of the device.
     * @interface
     */
    interface Altitude {
        'altitudeInMeters': number;
        'accuracyInMeters': number;
    }
}
export declare namespace interfaces.geolocation {
    /**
     * An object containing the location information of the device.
     * @interface
     */
    interface Coordinate {
        'latitudeInDegrees': number;
        'longitudeInDegrees': number;
        'accuracyInMeters': number;
    }
}
export declare namespace interfaces.geolocation {
    /**
     *
     * @interface
     */
    interface GeolocationInterface {
    }
}
export declare namespace interfaces.geolocation {
    /**
     *
     * @interface
     */
    interface GeolocationState {
        'timestamp'?: string;
        'coordinate'?: interfaces.geolocation.Coordinate;
        'altitude'?: interfaces.geolocation.Altitude;
        'heading'?: interfaces.geolocation.Heading;
        'speed'?: interfaces.geolocation.Speed;
        'locationServices'?: interfaces.geolocation.LocationServices;
    }
}
export declare namespace interfaces.geolocation {
    /**
     * An object containing the heading direction information of the device.
     * @interface
     */
    interface Heading {
        'directionInDegrees': number;
        'accuracyInDegrees'?: number;
    }
}
export declare namespace interfaces.geolocation {
    /**
     * An object containing status and access.
     * @interface
     */
    interface LocationServices {
        'status': interfaces.geolocation.Status;
        'access': interfaces.geolocation.Access;
    }
}
export declare namespace interfaces.geolocation {
    /**
     * An object containing the speed information of the device.
     * @interface
     */
    interface Speed {
        'speedInMetersPerSecond': number;
        'accuracyInMetersPerSecond'?: number;
    }
}
export declare namespace interfaces.geolocation {
    /**
     * A string representing the status of whether location services is currently running or not on the host OS of device.
     * @enum
     */
    type Status = 'RUNNING' | 'STOPPED';
}
export declare namespace interfaces.monetization.v1 {
    /**
     * Entity to define In Skill Product over which actions will be performed.
     * @interface
     */
    interface InSkillProduct {
        'productId': string;
    }
}
export declare namespace interfaces.monetization.v1 {
    /**
     * Response from purchase directives:   * ACCEPTED - User have accepted the offer to purchase the product   * DECLINED - User have declined the offer to purchase the product   * NOT_ENTITLED - User tries to cancel/return a product he/she is  not entitled to.   * ALREADY_PURCHASED - User has already purchased the product   * ERROR - An internal error occurred
     * @enum
     */
    type PurchaseResult = 'ACCEPTED' | 'DECLINED' | 'NOT_ENTITLED' | 'ERROR' | 'ALREADY_PURCHASED';
}
export declare namespace interfaces.navigation {
    /**
     *
     * @interface
     */
    interface NavigationInterface {
    }
}
export declare namespace interfaces.system {
    /**
     *
     * @interface
     */
    interface Error {
        'type': interfaces.system.ErrorType;
        'message'?: string;
    }
}
export declare namespace interfaces.system {
    /**
     *
     * @interface
     */
    interface ErrorCause {
        'requestId': string;
    }
}
export declare namespace interfaces.system {
    /**
     *
     * @enum
     */
    type ErrorType = 'INVALID_RESPONSE' | 'DEVICE_COMMUNICATION_ERROR' | 'INTERNAL_SERVICE_ERROR';
}
export declare namespace interfaces.system {
    /**
     *
     * @interface
     */
    interface SystemState {
        'application': Application;
        'user': User;
        'device'?: Device;
        'person'?: Person;
        'unit'?: interfaces.systemUnit.Unit;
        'apiEndpoint': string;
        'apiAccessToken'?: string;
    }
}
export declare namespace interfaces.systemUnit {
    /**
     * An object that represents a logical entity for organizing actors and resources that interact with Alexa systems.
     * @interface
     */
    interface Unit {
        'unitId'?: string;
        'persistentUnitId'?: string;
    }
}
export declare namespace interfaces.videoapp {
    /**
     *
     * @interface
     */
    interface Metadata {
        'title'?: string;
        'subtitle'?: string;
    }
}
export declare namespace interfaces.videoapp {
    /**
     *
     * @interface
     */
    interface VideoAppInterface {
    }
}
export declare namespace interfaces.videoapp {
    /**
     *
     * @interface
     */
    interface VideoItem {
        'source': string;
        'metadata'?: interfaces.videoapp.Metadata;
    }
}
export declare namespace interfaces.viewport {
    /**
     * Indicates that dialog playback is supported or desired in the given interaction mode. Player interface abilities controlled by this field are any directives that would render audio on the dialog channel.
     * @enum
     */
    type Dialog = 'SUPPORTED' | 'UNSUPPORTED';
}
export declare namespace interfaces.viewport {
    /**
     * An experience represents a viewing mode used to interact with the device.
     * @interface
     */
    interface Experience {
        'arcMinuteWidth'?: number;
        'arcMinuteHeight'?: number;
        'canRotate'?: boolean;
        'canResize'?: boolean;
    }
}
export declare namespace interfaces.viewport {
    /**
     * Represents a physical button input mechanism which can be used to interact with elements shown on the viewport.
     * @enum
     */
    type Keyboard = 'DIRECTION';
}
export declare namespace interfaces.viewport {
    /**
     * The expected use case of the device's viewport, encapsulating the available input mechanisms and user viewing distance.
     * @enum
     */
    type Mode = 'AUTO' | 'HUB' | 'MOBILE' | 'PC' | 'TV';
}
export declare namespace interfaces.viewport {
    /**
     * Type of the viewport.   * `STANDARD` Indicates that this viewport occupies an exclusive area of the screen.   * `OVERLAY` Indicates that the viewport is an overlay, sharing the screen with other experiences.
     * @enum
     */
    type PresentationType = 'STANDARD' | 'OVERLAY';
}
export declare namespace interfaces.viewport {
    /**
     * The shape of the viewport.
     * @enum
     */
    type Shape = 'RECTANGLE' | 'ROUND';
}
export declare namespace interfaces.viewport {
    /**
     * Represents a type of touch input suppported by the device.
     * @enum
     */
    type Touch = 'SINGLE';
}
export declare namespace interfaces.viewport {
    /**
     *
     * @interface
     */
    type TypedViewportState = interfaces.viewport.APLViewportState | interfaces.viewport.APLTViewportState;
}
export declare namespace interfaces.viewport {
    /**
     * This object contains the characteristics related to the device's viewport.
     * @interface
     */
    interface ViewportState {
        'experiences'?: Array<interfaces.viewport.Experience>;
        'mode'?: interfaces.viewport.Mode;
        'shape'?: interfaces.viewport.Shape;
        'pixelWidth'?: number;
        'pixelHeight'?: number;
        'dpi'?: number;
        'currentPixelWidth'?: number;
        'currentPixelHeight'?: number;
        'touch'?: Array<interfaces.viewport.Touch>;
        'keyboard'?: Array<interfaces.viewport.Keyboard>;
        'video'?: interfaces.viewport.ViewportStateVideo;
    }
}
export declare namespace interfaces.viewport {
    /**
     * Details of the technologies which are available for playing video on the device.
     * @interface
     */
    interface ViewportStateVideo {
        'codecs'?: Array<interfaces.viewport.video.Codecs>;
    }
}
export declare namespace interfaces.viewport {
    /**
     * Details of the technologies which are available for playing video on the device.
     * @interface
     */
    interface ViewportVideo {
        'codecs'?: Array<interfaces.viewport.video.Codecs>;
    }
}
export declare namespace interfaces.viewport.apl {
    /**
     * The viewport configuration at the time of the request.
     * @interface
     */
    interface CurrentConfiguration {
        'mode': interfaces.viewport.Mode;
        'video'?: interfaces.viewport.ViewportVideo;
        'size': interfaces.viewport.size.ViewportSize;
        'dialog'?: interfaces.viewport.Dialog;
    }
}
export declare namespace interfaces.viewport.apl {
    /**
     *
     * @interface
     */
    interface ViewportConfiguration {
        'current': interfaces.viewport.apl.CurrentConfiguration;
    }
}
export declare namespace interfaces.viewport.aplt {
    /**
     * Supported character set on a text display   * `SEVEN_SEGMENT` - 7-segment display
     * @enum
     */
    type CharacterFormat = 'SEVEN_SEGMENT';
}
export declare namespace interfaces.viewport.aplt {
    /**
     *
     * @interface
     */
    interface InterSegment {
        'x': number;
        'y': number;
        'characters': string;
    }
}
export declare namespace interfaces.viewport.aplt {
    /**
     * name of viewport's profile
     * @enum
     */
    type ViewportProfile = 'FOUR_CHARACTER_CLOCK';
}
export declare namespace interfaces.viewport.size {
    /**
     * Information regarding the range of sizes for a configuration.
     * @interface
     */
    type ViewportSize = interfaces.viewport.size.ContinuousViewportSize | interfaces.viewport.size.DiscreteViewportSize;
}
export declare namespace interfaces.viewport.video {
    /**
     * A named bundle of codecs which are available for playing video on the viewport.
     * @enum
     */
    type Codecs = 'H_264_41' | 'H_264_42';
}
export declare namespace services.deviceAddress {
    /**
     * Represents the full address response from the service.
     * @interface
     */
    interface Address {
        'addressLine1'?: string;
        'addressLine2'?: string;
        'addressLine3'?: string;
        'countryCode'?: string;
        'stateOrRegion'?: string;
        'city'?: string;
        'districtOrCounty'?: string;
        'postalCode'?: string;
    }
}
export declare namespace services.deviceAddress {
    /**
     *
     * @interface
     */
    interface Error {
        'type'?: string;
        'message'?: string;
    }
}
export declare namespace services.deviceAddress {
    /**
     *
     * @interface
     */
    interface ShortAddress {
        'countryCode'?: string;
        'postalCode'?: string;
    }
}
export declare namespace services.directive {
    /**
     *
     * @interface
     */
    type Directive = services.directive.SpeakDirective;
}
export declare namespace services.directive {
    /**
     *
     * @interface
     */
    interface Error {
        'code': number;
        'message': string;
    }
}
export declare namespace services.directive {
    /**
     *
     * @interface
     */
    interface Header {
        'requestId': string;
    }
}
export declare namespace services.directive {
    /**
     * Send Directive Request payload.
     * @interface
     */
    interface SendDirectiveRequest {
        'header': services.directive.Header;
        'directive': services.directive.Directive;
    }
}
export declare namespace services.endpointEnumeration {
    /**
     *
     * @interface
     */
    interface EndpointCapability {
        'interface'?: string;
        'type'?: string;
        'version'?: string;
    }
}
export declare namespace services.endpointEnumeration {
    /**
     * Contains the list of endpoints.
     * @interface
     */
    interface EndpointEnumerationResponse {
        'endpoints'?: Array<services.endpointEnumeration.EndpointInfo>;
    }
}
export declare namespace services.endpointEnumeration {
    /**
     * Contains the list of connected endpoints and their declared capabilities.
     * @interface
     */
    interface EndpointInfo {
        'endpointId'?: string;
        'friendlyName'?: string;
        'capabilities'?: Array<services.endpointEnumeration.EndpointCapability>;
    }
}
export declare namespace services.endpointEnumeration {
    /**
     *
     * @interface
     */
    interface Error {
        'code'?: string;
        'message'?: string;
    }
}
export declare namespace services.gadgetController {
    /**
     * The action that triggers the animation. Possible values are as follows   * `buttonDown` - Play the animation when the button is pressed.   * `buttonUp` - Play the animation when the button is released.   * `none` - Play the animation as soon as it arrives.
     * @enum
     */
    type TriggerEventType = 'buttonDown' | 'buttonUp' | 'none';
}
export declare namespace services.gadgetController {
    /**
     *
     * @interface
     */
    interface AnimationStep {
        'durationMs': number;
        'color': string;
        'blend': boolean;
    }
}
export declare namespace services.gadgetController {
    /**
     *
     * @interface
     */
    interface LightAnimation {
        'repeat'?: number;
        'targetLights'?: Array<string>;
        'sequence'?: Array<services.gadgetController.AnimationStep>;
    }
}
export declare namespace services.gadgetController {
    /**
     * Arguments that pertain to animating the buttons.
     * @interface
     */
    interface SetLightParameters {
        'triggerEvent'?: services.gadgetController.TriggerEventType;
        'triggerEventTimeMs'?: number;
        'animations'?: Array<services.gadgetController.LightAnimation>;
    }
}
export declare namespace services.gameEngine {
    /**
     * Specifies what raw button presses to put in the inputEvents field of the event.  * history - All button presses since this Input Handler was started. * matches - Just the button presses that contributed to this event (that is, were in the recognizers). To receive no raw button presses, leave this array empty or do not specify it at all.
     * @enum
     */
    type EventReportingType = 'history' | 'matches';
}
export declare namespace services.gameEngine {
    /**
     *
     * @interface
     */
    interface InputEvent {
        'gadgetId'?: string;
        'timestamp'?: string;
        'action'?: services.gameEngine.InputEventActionType;
        'color'?: string;
        'feature'?: string;
    }
}
export declare namespace services.gameEngine {
    /**
     * Either \"down\" for a button pressed or \"up\" for a button released.
     * @enum
     */
    type InputEventActionType = 'down' | 'up';
}
export declare namespace services.gameEngine {
    /**
     *
     * @interface
     */
    interface InputHandlerEvent {
        'name'?: string;
        'inputEvents'?: Array<services.gameEngine.InputEvent>;
    }
}
export declare namespace services.gameEngine {
    /**
     * Where the pattern must appear in the history of this input handler. * `start` -  (Default) The first event in the pattern must be the first event in the history of raw Echo Button events. * `end` - The last event in the pattern must be the last event in the history of raw Echo Button events. * `anywhere` - The pattern may appear anywhere in the history of raw Echo Button events.
     * @enum
     */
    type PatternRecognizerAnchorType = 'start' | 'end' | 'anywhere';
}
export declare namespace services.gameEngine {
    /**
     * The events object is where you define the conditions that must be met for your skill to be notified of Echo Button input. You must define at least one event.
     * @interface
     */
    interface Event {
        'shouldEndInputHandler': boolean;
        'meets': Array<string>;
        'fails'?: Array<string>;
        'reports'?: services.gameEngine.EventReportingType;
        'maximumInvocations'?: number;
        'triggerTimeMilliseconds'?: number;
    }
}
export declare namespace services.gameEngine {
    /**
     * An object that provides all of the events that need to occur, in a specific order, for this recognizer to be true. Omitting any parameters in this object means \"match anything\".
     * @interface
     */
    interface Pattern {
        'gadgetIds'?: Array<string>;
        'colors'?: Array<string>;
        'action'?: services.gameEngine.InputEventActionType;
        'repeat'?: number;
    }
}
export declare namespace services.gameEngine {
    /**
     * Recognizers are conditions that, at any moment, are either true or false, based on all the raw button events that the Input Handler has received in the time elapsed since the Input Handler session started.
     * @interface
     */
    type Recognizer = services.gameEngine.PatternRecognizer | services.gameEngine.DeviationRecognizer | services.gameEngine.ProgressRecognizer;
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface AlexaList {
        'listId'?: string;
        'name'?: string;
        'state'?: services.listManagement.ListState;
        'version'?: number;
        'items'?: Array<services.listManagement.AlexaListItem>;
        'links'?: services.listManagement.Links;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface AlexaListItem {
        'id'?: string;
        'version'?: number;
        'value'?: string;
        'status'?: services.listManagement.ListItemState;
        'createdTime'?: string;
        'updatedTime'?: string;
        'href'?: string;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface AlexaListMetadata {
        'listId'?: string;
        'name'?: string;
        'state'?: services.listManagement.ListState;
        'version'?: number;
        'statusMap'?: Array<services.listManagement.Status>;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface AlexaListsMetadata {
        'lists'?: Array<services.listManagement.AlexaListMetadata>;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface CreateListItemRequest {
        'value'?: string;
        'status'?: services.listManagement.ListItemState;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface CreateListRequest {
        'name'?: string;
        'state'?: services.listManagement.ListState;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface Error {
        'type'?: string;
        'message'?: string;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface ForbiddenError {
        'Message'?: string;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface Links {
        'next'?: string;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface ListBody {
        'listId'?: string;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface ListItemBody {
        'listId'?: string;
        'listItemIds'?: Array<string>;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @enum
     */
    type ListItemState = 'active' | 'completed';
}
export declare namespace services.listManagement {
    /**
     *
     * @enum
     */
    type ListState = 'active' | 'archived';
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface Status {
        'url'?: string;
        'status'?: services.listManagement.ListItemState;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface UpdateListItemRequest {
        'value'?: string;
        'status'?: services.listManagement.ListItemState;
        'version'?: number;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface UpdateListRequest {
        'name'?: string;
        'state'?: services.listManagement.ListState;
        'version'?: number;
    }
}
export declare namespace services.monetization {
    /**
     * State determining if the user is entitled to the product. Note - Any new values introduced later should be treated as 'NOT_ENTITLED'. * 'ENTITLED' - The user is entitled to the product. * 'NOT_ENTITLED' - The user is not entitled to the product.
     * @enum
     */
    type EntitledState = 'ENTITLED' | 'NOT_ENTITLED';
}
export declare namespace services.monetization {
    /**
     * Reason for the entitlement status. * 'PURCHASED' - The user is entitled to the product because they purchased it. * 'NOT_PURCHASED' - The user is not entitled to the product because they have not purchased it. * 'AUTO_ENTITLED' - The user is auto entitled to the product because they have subscribed to a broader service.
     * @enum
     */
    type EntitlementReason = 'PURCHASED' | 'NOT_PURCHASED' | 'AUTO_ENTITLED';
}
export declare namespace services.monetization {
    /**
     * Describes error detail
     * @interface
     */
    interface Error {
        'message'?: string;
    }
}
export declare namespace services.monetization {
    /**
     *
     * @interface
     */
    interface InSkillProduct {
        'productId': string;
        'referenceName': string;
        'name': string;
        'type': services.monetization.ProductType;
        'summary': string;
        'purchasable': services.monetization.PurchasableState;
        'entitled': services.monetization.EntitledState;
        'entitlementReason': services.monetization.EntitlementReason;
        'activeEntitlementCount': number;
        'purchaseMode': services.monetization.PurchaseMode;
    }
}
export declare namespace services.monetization {
    /**
     *
     * @interface
     */
    interface InSkillProductTransactionsResponse {
        'results': Array<services.monetization.Transactions>;
        'metadata': services.monetization.Metadata;
    }
}
export declare namespace services.monetization {
    /**
     *
     * @interface
     */
    interface InSkillProductsResponse {
        'inSkillProducts': Array<services.monetization.InSkillProduct>;
        'isTruncated': boolean;
        'nextToken': string;
    }
}
export declare namespace services.monetization {
    /**
     *
     * @interface
     */
    interface Metadata {
        'resultSet'?: services.monetization.ResultSet;
    }
}
export declare namespace services.monetization {
    /**
     * Product type. * 'SUBSCRIPTION' - Once purchased, customers will own the content for the subscription period. * 'ENTITLEMENT' - Once purchased, customers will own the content forever. * 'CONSUMABLE' - Once purchased, customers will be entitled to the content until it is consumed. It can also be re-purchased.
     * @enum
     */
    type ProductType = 'SUBSCRIPTION' | 'ENTITLEMENT' | 'CONSUMABLE';
}
export declare namespace services.monetization {
    /**
     * State determining if the product is purchasable by the user. Note - Any new values introduced later should be treated as 'NOT_PURCHASABLE'. * 'PURCHASABLE' - The product is purchasable by the user. * 'NOT_PURCHASABLE' - The product is not purchasable by the user.
     * @enum
     */
    type PurchasableState = 'PURCHASABLE' | 'NOT_PURCHASABLE';
}
export declare namespace services.monetization {
    /**
     * Indicates if the entitlements are for TEST or LIVE purchases. * 'TEST' - test purchases made by developers or beta testers. Purchase not sent to payment processing. * 'LIVE' - purchases made by live customers. Purchase sent to payment processing.
     * @enum
     */
    type PurchaseMode = 'TEST' | 'LIVE';
}
export declare namespace services.monetization {
    /**
     *
     * @interface
     */
    interface ResultSet {
        'nextToken'?: string;
    }
}
export declare namespace services.monetization {
    /**
     * Transaction status for in skill product purchases. * 'PENDING_APPROVAL_BY_PARENT' - The transaction is pending approval from parent. * 'APPROVED_BY_PARENT' - The transaction was approved by parent and fulfilled successfully.. * 'DENIED_BY_PARENT' - The transaction was declined by parent and hence not fulfilled. * 'EXPIRED_NO_ACTION_BY_PARENT' - The transaction was expired due to no response from parent and hence not fulfilled. * 'ERROR' - The transaction was not fullfiled as there was an error while processing the transaction.
     * @enum
     */
    type Status = 'PENDING_APPROVAL_BY_PARENT' | 'APPROVED_BY_PARENT' | 'DENIED_BY_PARENT' | 'EXPIRED_NO_ACTION_BY_PARENT' | 'ERROR';
}
export declare namespace services.monetization {
    /**
     *
     * @interface
     */
    interface Transactions {
        'status'?: services.monetization.Status;
        'productId'?: string;
        'createdTime'?: string;
        'lastModifiedTime'?: string;
    }
}
export declare namespace services.proactiveEvents {
    /**
     *
     * @interface
     */
    interface CreateProactiveEventRequest {
        'timestamp': string;
        'referenceId': string;
        'expiryTime': string;
        'event': services.proactiveEvents.Event;
        'localizedAttributes': Array<any>;
        'relevantAudience': services.proactiveEvents.RelevantAudience;
    }
}
export declare namespace services.proactiveEvents {
    /**
     *
     * @interface
     */
    interface Error {
        'code'?: number;
        'message'?: string;
    }
}
export declare namespace services.proactiveEvents {
    /**
     * The event data to be sent to customers, conforming to the schema associated with this event.
     * @interface
     */
    interface Event {
        'name': string;
        'payload': any;
    }
}
export declare namespace services.proactiveEvents {
    /**
     * The audience for this event.
     * @interface
     */
    interface RelevantAudience {
        'type': services.proactiveEvents.RelevantAudienceType;
        'payload': any;
    }
}
export declare namespace services.proactiveEvents {
    /**
     * The audience for this event. Use Multicast to target information to all customers subscribed to that event, or use Unicast to target information containing the actual userId for individual events.
     * @enum
     */
    type RelevantAudienceType = 'Unicast' | 'Multicast';
}
export declare namespace services.proactiveEvents {
    /**
     * Stage for creating Proactive events. Since proactive events can be created on the DEVELOPMENT and LIVE stages of the skill, this enum provides the stage values that can be used to pass to the service call.
     * @enum
     */
    type SkillStage = 'DEVELOPMENT' | 'LIVE';
}
export declare namespace services.reminderManagement {
    /**
     *
     * @interface
     */
    interface Error {
        'code'?: string;
        'message'?: string;
    }
}
export declare namespace services.reminderManagement {
    /**
     *
     * @interface
     */
    interface Event {
        'status'?: services.reminderManagement.Status;
        'alertToken'?: string;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Response object for get reminders request
     * @interface
     */
    interface GetRemindersResponse {
        'totalCount'?: string;
        'alerts'?: Array<services.reminderManagement.Reminder>;
        'links'?: string;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Reminder object
     * @interface
     */
    interface Reminder {
        'alertToken'?: string;
        'createdTime'?: string;
        'updatedTime'?: string;
        'status'?: services.reminderManagement.Status;
        'trigger'?: services.reminderManagement.Trigger;
        'alertInfo'?: services.reminderManagement.AlertInfo;
        'pushNotification'?: services.reminderManagement.PushNotification;
        'version'?: string;
    }
}
export declare namespace services.reminderManagement {
    /**
     *
     * @interface
     */
    interface ReminderDeletedEvent {
        'alertTokens'?: Array<string>;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Input request for creating a reminder
     * @interface
     */
    interface ReminderRequest {
        'requestTime'?: string;
        'trigger'?: services.reminderManagement.Trigger;
        'alertInfo'?: services.reminderManagement.AlertInfo;
        'pushNotification'?: services.reminderManagement.PushNotification;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Response object for post/put/delete reminder request
     * @interface
     */
    interface ReminderResponse {
        'alertToken'?: string;
        'createdTime'?: string;
        'updatedTime'?: string;
        'status'?: services.reminderManagement.Status;
        'version'?: string;
        'href'?: string;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Alert info for VUI / GUI
     * @interface
     */
    interface AlertInfo {
        'spokenInfo'?: services.reminderManagement.AlertInfoSpokenInfo;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Parameters for VUI presentation of the reminder
     * @interface
     */
    interface AlertInfoSpokenInfo {
        'content': Array<services.reminderManagement.SpokenText>;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Enable / disable reminders push notifications to Alexa mobile apps
     * @interface
     */
    interface PushNotification {
        'status'?: services.reminderManagement.PushNotificationStatus;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Push notification status - Enabled/Disabled
     * @enum
     */
    type PushNotificationStatus = 'ENABLED' | 'DISABLED';
}
export declare namespace services.reminderManagement {
    /**
     * Recurring date/time using the RFC 5545 standard in JSON object form
     * @interface
     */
    interface Recurrence {
        'freq'?: services.reminderManagement.RecurrenceFreq;
        'byDay'?: Array<services.reminderManagement.RecurrenceDay>;
        'interval'?: number;
        'startDateTime'?: string;
        'endDateTime'?: string;
        'recurrenceRules'?: Array<string>;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Day of recurrence. Deprecated.
     * @enum
     */
    type RecurrenceDay = 'SU' | 'MO' | 'TU' | 'WE' | 'TH' | 'FR' | 'SA';
}
export declare namespace services.reminderManagement {
    /**
     * Frequency of recurrence. Deprecated.
     * @enum
     */
    type RecurrenceFreq = 'WEEKLY' | 'DAILY';
}
export declare namespace services.reminderManagement {
    /**
     *
     * @interface
     */
    interface SpokenText {
        'locale'?: string;
        'ssml'?: string;
        'text'?: string;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Status of reminder
     * @enum
     */
    type Status = 'ON' | 'COMPLETED';
}
export declare namespace services.reminderManagement {
    /**
     * Trigger information for Reminder
     * @interface
     */
    interface Trigger {
        'type'?: services.reminderManagement.TriggerType;
        'scheduledTime'?: string;
        'offsetInSeconds'?: number;
        'timeZoneId'?: string;
        'recurrence'?: services.reminderManagement.Recurrence;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Type of reminder - Absolute / Relative
     * @enum
     */
    type TriggerType = 'SCHEDULED_ABSOLUTE' | 'SCHEDULED_RELATIVE';
}
export declare namespace services.skillMessaging {
    /**
     *
     * @interface
     */
    interface Error {
        'code'?: number;
        'message'?: string;
    }
}
export declare namespace services.skillMessaging {
    /**
     * The message that needs to be sent to the skill
     * @interface
     */
    interface SendSkillMessagingRequest {
        'data': any;
        'expiresAfterSeconds'?: number;
    }
}
export declare namespace services.timerManagement {
    /**
     * Whether the native Timer GUI is shown for 8-seconds upon Timer Creation.
     * @interface
     */
    interface CreationBehavior {
        'displayExperience'?: services.timerManagement.DisplayExperience;
    }
}
export declare namespace services.timerManagement {
    /**
     * Multi model presentation of the timer creation.
     * @interface
     */
    interface DisplayExperience {
        'visibility'?: services.timerManagement.Visibility;
    }
}
export declare namespace services.timerManagement {
    /**
     * Error object for Response.
     * @interface
     */
    interface Error {
        'code'?: string;
        'message'?: string;
    }
}
export declare namespace services.timerManagement {
    /**
     * notification of the timer expiration.
     * @interface
     */
    interface NotificationConfig {
        'playAudible'?: boolean;
    }
}
export declare namespace services.timerManagement {
    /**
     * Triggering information for Timer.
     * @interface
     */
    type Operation = services.timerManagement.LaunchTaskOperation | services.timerManagement.AnnounceOperation | services.timerManagement.NotifyOnlyOperation;
}
export declare namespace services.timerManagement {
    /**
     * Status of timer
     * @enum
     */
    type Status = 'ON' | 'PAUSED' | 'OFF';
}
export declare namespace services.timerManagement {
    /**
     * Custom task passed by skill developers when the operation type is \"LAUNCH_TASK\"
     * @interface
     */
    interface Task {
        'name'?: string;
        'version'?: string;
        'input'?: any;
    }
}
export declare namespace services.timerManagement {
    /**
     * When the operation type is \"ANNOUNCE\", announces a certain text that the developer wants to be read out at the expiration of the timer.
     * @interface
     */
    interface TextToAnnounce {
        'locale'?: string;
        'text'?: string;
    }
}
export declare namespace services.timerManagement {
    /**
     * When the operation type is \"LAUNCH_TASK\", confirm with the customer at the expiration of the timer.
     * @interface
     */
    interface TextToConfirm {
        'locale'?: string;
        'text'?: string;
    }
}
export declare namespace services.timerManagement {
    /**
     * Input request for creating a timer.
     * @interface
     */
    interface TimerRequest {
        'duration': string;
        'timerLabel'?: string;
        'creationBehavior': services.timerManagement.CreationBehavior;
        'triggeringBehavior': services.timerManagement.TriggeringBehavior;
    }
}
export declare namespace services.timerManagement {
    /**
     * Timer object
     * @interface
     */
    interface TimerResponse {
        'id'?: string;
        'status'?: services.timerManagement.Status;
        'duration'?: string;
        'triggerTime'?: string;
        'timerLabel'?: string;
        'createdTime'?: string;
        'updatedTime'?: string;
        'remainingTimeWhenPaused'?: string;
    }
}
export declare namespace services.timerManagement {
    /**
     * Timers object with paginated list of multiple timers
     * @interface
     */
    interface TimersResponse {
        'totalCount'?: number;
        'timers'?: Array<services.timerManagement.TimerResponse>;
        'nextToken'?: string;
    }
}
export declare namespace services.timerManagement {
    /**
     * The triggering behavior upon Timer Expired.
     * @interface
     */
    interface TriggeringBehavior {
        'operation'?: services.timerManagement.Operation;
        'notificationConfig'?: services.timerManagement.NotificationConfig;
    }
}
export declare namespace services.timerManagement {
    /**
     * The default native Timer GUI \"visible\" is shown for 8-seconds upon Timer Creation. Otherwise, \"hidden\" will not show default native Timer GUI.
     * @enum
     */
    type Visibility = 'VISIBLE' | 'HIDDEN';
}
export declare namespace services.ups {
    /**
     *
     * @enum
     */
    type DistanceUnits = 'METRIC' | 'IMPERIAL';
}
export declare namespace services.ups {
    /**
     *
     * @interface
     */
    interface Error {
        'code'?: services.ups.ErrorCode;
        'message'?: string;
    }
}
export declare namespace services.ups {
    /**
     * A more precise error code. Some of these codes may not apply to some APIs. - INVALID_KEY: the setting key is not supported - INVALID_VALUE: the setting value is not valid - INVALID_TOKEN: the token is invalid - INVALID_URI: the uri is invalid - DEVICE_UNREACHABLE: the device is offline - UNKNOWN_ERROR: internal service error
     * @enum
     */
    type ErrorCode = 'INVALID_KEY' | 'INVALID_VALUE' | 'INVALID_TOKEN' | 'INVALID_URI' | 'DEVICE_UNREACHABLE' | 'UNKNOWN_ERROR';
}
export declare namespace services.ups {
    /**
     *
     * @interface
     */
    interface PhoneNumber {
        'countryCode'?: string;
        'phoneNumber'?: string;
    }
}
export declare namespace services.ups {
    /**
     *
     * @enum
     */
    type TemperatureUnit = 'CELSIUS' | 'FAHRENHEIT';
}
export declare namespace slu.entityresolution {
    /**
     * Represents a possible authority for entity resolution
     * @interface
     */
    interface Resolution {
        'authority': string;
        'status': slu.entityresolution.Status;
        'values': Array<slu.entityresolution.ValueWrapper>;
    }
}
export declare namespace slu.entityresolution {
    /**
     * Represents the results of resolving the words captured from the user's utterance. This is included for slots that use a custom slot type or a built-in slot type that you have extended with your own values. Note that resolutions is not included for built-in slot types that you have not extended.
     * @interface
     */
    interface Resolutions {
        'resolutionsPerAuthority'?: Array<slu.entityresolution.Resolution>;
    }
}
export declare namespace slu.entityresolution {
    /**
     *
     * @interface
     */
    interface Status {
        'code': slu.entityresolution.StatusCode;
    }
}
export declare namespace slu.entityresolution {
    /**
     * Indication of the results of attempting to resolve the user utterance against the defined slot types.
     * @enum
     */
    type StatusCode = 'ER_SUCCESS_MATCH' | 'ER_SUCCESS_NO_MATCH' | 'ER_ERROR_TIMEOUT' | 'ER_ERROR_EXCEPTION';
}
export declare namespace slu.entityresolution {
    /**
     * Represents the resolved value for the slot, based on the user’s utterance and slot type definition.
     * @interface
     */
    interface Value {
        'name': string;
        'id': string;
    }
}
export declare namespace slu.entityresolution {
    /**
     * A wrapper class for an entity resolution value used for JSON serialization.
     * @interface
     */
    interface ValueWrapper {
        'value': slu.entityresolution.Value;
    }
}
export declare namespace ui {
    /**
     *
     * @interface
     */
    type Card = ui.AskForPermissionsConsentCard | ui.LinkAccountCard | ui.StandardCard | ui.SimpleCard;
}
export declare namespace ui {
    /**
     *
     * @interface
     */
    interface Image {
        'smallImageUrl'?: string;
        'largeImageUrl'?: string;
    }
}
export declare namespace ui {
    /**
     *
     * @interface
     */
    type OutputSpeech = ui.SsmlOutputSpeech | ui.PlainTextOutputSpeech;
}
export declare namespace ui {
    /**
     * Determines whether Alexa will queue or play this output speech immediately interrupting other speech
     * @enum
     */
    type PlayBehavior = 'ENQUEUE' | 'REPLACE_ALL' | 'REPLACE_ENQUEUED';
}
export declare namespace ui {
    /**
     *
     * @interface
     */
    interface Reprompt {
        'outputSpeech': ui.OutputSpeech;
    }
}
/**
 * Represents the status and result needed to resume a skill's suspended session.
 * @interface
 */
export interface ConnectionCompleted {
    'type': 'ConnectionCompleted';
    'token'?: string;
    'status'?: Status;
    'result'?: any;
}
/**
 * An IntentRequest is an object that represents a request made to a skill based on what the user wants to do.
 * @interface
 */
export interface IntentRequest {
    'type': 'IntentRequest';
    'requestId': string;
    'timestamp': string;
    'locale'?: string;
    'dialogState': DialogState;
    'intent': Intent;
}
/**
 * Represents that a user made a request to an Alexa skill, but did not provide a specific intent.
 * @interface
 */
export interface LaunchRequest {
    'type': 'LaunchRequest';
    'requestId': string;
    'timestamp': string;
    'locale'?: string;
    'task'?: Task;
}
/**
 * Slot value containing a list of other slot value objects.
 * @interface
 */
export interface ListSlotValue {
    'type': 'List';
    'values': Array<SlotValue>;
}
/**
 * A SessionEndedRequest is an object that represents a request made to an Alexa skill to notify that a session was ended. Your service receives a SessionEndedRequest when a currently open session is closed for one of the following reasons: <ol><li>The user says “exit”</li><li>the user does not respond or says something that does not match an intent defined in your voice interface while the device is listening for the user’s response</li><li>an error occurs</li></ol>
 * @interface
 */
export interface SessionEndedRequest {
    'type': 'SessionEndedRequest';
    'requestId': string;
    'timestamp': string;
    'locale'?: string;
    'reason': SessionEndedReason;
    'error'?: SessionEndedError;
}
/**
 * The request to resume a skill's session and tells the skill why it is resumed.
 * @interface
 */
export interface SessionResumedRequest {
    'type': 'SessionResumedRequest';
    'requestId': string;
    'timestamp': string;
    'locale'?: string;
    'cause'?: Cause;
}
/**
 * Slot value containing a single string value and resolutions.
 * @interface
 */
export interface SimpleSlotValue {
    'type': 'Simple';
    'value'?: string;
    'resolutions'?: slu.entityresolution.Resolutions;
}
export declare namespace authorization {
    /**
     * Represents an authorization code delivered to a skill that has out-of-session permissions without requiring account linking.
     * @interface
     */
    interface AuthorizationGrantRequest {
        'type': 'Alexa.Authorization.Grant';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body': authorization.AuthorizationGrantBody;
    }
}
export declare namespace canfulfill {
    /**
     * An object that represents a request made to skill to query whether the skill can understand and fulfill the intent request with detected slots, before actually asking the skill to take action. Skill should be aware this is not to actually take action, skill should handle this request without causing side-effect, skill should not modify some state outside its scope or has an observable interaction with its calling functions or the outside world besides returning a value, such as playing sound,turning on/off lights, committing a transaction or a charge.
     * @interface
     */
    interface CanFulfillIntentRequest {
        'type': 'CanFulfillIntentRequest';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'dialogState'?: DialogState;
        'intent': Intent;
    }
}
export declare namespace dialog {
    /**
     *
     * @interface
     */
    interface ConfirmIntentDirective {
        'type': 'Dialog.ConfirmIntent';
        'updatedIntent'?: Intent;
    }
}
export declare namespace dialog {
    /**
     *
     * @interface
     */
    interface ConfirmSlotDirective {
        'type': 'Dialog.ConfirmSlot';
        'updatedIntent'?: Intent;
        'slotToConfirm': string;
    }
}
export declare namespace dialog {
    /**
     *
     * @interface
     */
    interface DelegateDirective {
        'type': 'Dialog.Delegate';
        'updatedIntent'?: Intent;
    }
}
export declare namespace dialog {
    /**
     *
     * @interface
     */
    interface DelegateRequestDirective {
        'type': 'Dialog.DelegateRequest';
        'target': string;
        'period': dialog.DelegationPeriod;
        'updatedRequest'?: dialog.UpdatedRequest;
    }
}
export declare namespace dialog {
    /**
     *
     * @interface
     */
    interface DynamicEntitiesDirective {
        'type': 'Dialog.UpdateDynamicEntities';
        'updateBehavior': er.dynamic.UpdateBehavior;
        'types'?: Array<er.dynamic.EntityListItem>;
    }
}
export declare namespace dialog {
    /**
     *
     * @interface
     */
    interface ElicitSlotDirective {
        'type': 'Dialog.ElicitSlot';
        'updatedIntent'?: Intent;
        'slotToElicit': string;
    }
}
export declare namespace dialog {
    /**
     * A request representing structured data used to provide dialog input to a dialog manager.
     * @interface
     */
    interface InputRequest {
        'type': 'Dialog.InputRequest';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'input': dialog.Input;
    }
}
export declare namespace dialog {
    /**
     *
     * @interface
     */
    interface UpdatedInputRequest {
        'type': 'Dialog.InputRequest';
        'input': dialog.Input;
    }
}
export declare namespace dialog {
    /**
     *
     * @interface
     */
    interface UpdatedIntentRequest {
        'type': 'IntentRequest';
        'intent': Intent;
    }
}
export declare namespace dynamicEndpoints {
    /**
     * Failure skill response for a Dynamic endpoint request.
     * @interface
     */
    interface FailureResponse {
        'type': 'SkillResponseFailureMessage';
        'version': string;
        'originalRequestId': string;
        'errorCode'?: string;
        'errorMessage'?: string;
    }
}
export declare namespace dynamicEndpoints {
    /**
     * Success response for a Dynamic endpoint request.
     * @interface
     */
    interface SuccessResponse {
        'type': 'SkillResponseSuccessMessage';
        'version': string;
        'originalRequestId': string;
        'responsePayload'?: string;
    }
}
export declare namespace events.skillevents {
    /**
     * This event indicates that a customer has linked an account in a third-party application with the Alexa app. This event is useful for an application that support out-of-session (non-voice) user interactions so that this application can be notified when the internal customer can be associated with the Alexa customer. This event is required for many applications that synchronize customer Alexa lists with application lists. During the account linking process, the Alexa app directs the user to the skill website where the customer logs in. When the customer logs in, the skill then provides an access token and a consent token to Alexa. The event includes the same access token and consent token.
     * @interface
     */
    interface AccountLinkedRequest {
        'type': 'AlexaSkillEvent.SkillAccountLinked';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body': events.skillevents.AccountLinkedBody;
        'eventCreationTime'?: string;
        'eventPublishingTime'?: string;
    }
}
export declare namespace events.skillevents {
    /**
     *
     * @interface
     */
    interface PermissionAcceptedRequest {
        'type': 'AlexaSkillEvent.SkillPermissionAccepted';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: events.skillevents.PermissionBody;
        'eventCreationTime'?: string;
        'eventPublishingTime'?: string;
    }
}
export declare namespace events.skillevents {
    /**
     *
     * @interface
     */
    interface PermissionChangedRequest {
        'type': 'AlexaSkillEvent.SkillPermissionChanged';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: events.skillevents.PermissionBody;
        'eventCreationTime'?: string;
        'eventPublishingTime'?: string;
    }
}
export declare namespace events.skillevents {
    /**
     * This event indicates a customer subscription to receive events from your skill and contains information for that user and person, if recognized. You need this information to know the userId and personId in order to send events to individual users. Note that these events can arrive out of order, so ensure that your skill service uses the timestamp in the event to correctly record the latest subscription state for a customer.
     * @interface
     */
    interface ProactiveSubscriptionChangedRequest {
        'type': 'AlexaSkillEvent.ProactiveSubscriptionChanged';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body': events.skillevents.ProactiveSubscriptionChangedBody;
    }
}
export declare namespace events.skillevents {
    /**
     *
     * @interface
     */
    interface SkillDisabledRequest {
        'type': 'AlexaSkillEvent.SkillDisabled';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'eventCreationTime'?: string;
        'eventPublishingTime'?: string;
    }
}
export declare namespace events.skillevents {
    /**
     *
     * @interface
     */
    interface SkillEnabledRequest {
        'type': 'AlexaSkillEvent.SkillEnabled';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'eventCreationTime'?: string;
        'eventPublishingTime'?: string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Runs a fixed-duration animation sequence on one or more properties of a single component.
     * @interface
     */
    interface AnimateItemCommand {
        'type': 'AnimateItem';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'componentId': string;
        'duration': number | string;
        'easing'?: string;
        'repeatCount'?: number | string;
        'repeatMode'?: interfaces.alexa.presentation.apl.AnimateItemRepeatMode;
        'value': Array<interfaces.alexa.presentation.apl.AnimatedProperty>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     *
     * @interface
     */
    interface AnimatedOpacityProperty {
        'property': 'opacity';
        'from'?: number | string;
        'to': number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     *
     * @interface
     */
    interface AnimatedTransformProperty {
        'property': 'transform';
        'from': Array<interfaces.alexa.presentation.apl.TransformProperty>;
        'to': Array<interfaces.alexa.presentation.apl.TransformProperty>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Automatically progress through a series of pages displayed in a Pager component. The AutoPage command finishes after the last page has been displayed for the requested time period.
     * @interface
     */
    interface AutoPageCommand {
        'type': 'AutoPage';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'componentId': string;
        'count'?: number | string;
        'duration'?: number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Removes focus from the component that is currently in focus.
     * @interface
     */
    interface ClearFocusCommand {
        'type': 'ClearFocus';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Control a media player to play, pause, change tracks, or perform some other common action.
     * @interface
     */
    interface ControlMediaCommand {
        'type': 'ControlMedia';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'command': interfaces.alexa.presentation.apl.MediaCommandType;
        'componentId'?: string;
        'value'?: number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Alexa.Presentation.APL.ExecuteCommands directive used to send APL commands to a device.
     * @interface
     */
    interface ExecuteCommandsDirective {
        'type': 'Alexa.Presentation.APL.ExecuteCommands';
        'commands': Array<interfaces.alexa.presentation.apl.Command>;
        'token': string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The finish command closes the current APL document and exits.
     * @interface
     */
    interface FinishCommand {
        'type': 'Finish';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The idle command does nothing. It may be a placeholder or used to insert a calculated delay in a longer series of commands.
     * @interface
     */
    interface IdleCommand {
        'type': 'Idle';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Reports an error with list functionality.
     * @interface
     */
    interface ListRuntimeError {
        'type': 'LIST_ERROR';
        'message': string;
        'reason': interfaces.alexa.presentation.apl.ListRuntimeErrorReason;
        'listId': string;
        'listVersion'?: number;
        'operationIndex'?: number;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The LoadIndexListData event is sent to the skill to retrieve additional list items.
     * @interface
     */
    interface LoadIndexListDataEvent {
        'type': 'Alexa.Presentation.APL.LoadIndexListData';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'token': string;
        'correlationToken': string;
        'listId': string;
        'startIndex': number;
        'count': number;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     *
     * @interface
     */
    interface MoveTransformProperty {
        'translateX'?: string;
        'translateY'?: string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Opens a url with web browser or other application on the device. The APL author is responsible for providing a suitable URL that works on the current device.
     * @interface
     */
    interface OpenUrlCommand {
        'type': 'OpenURL';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'source': string;
        'onFail'?: Array<interfaces.alexa.presentation.apl.Command>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Execute a series of commands in parallel. The parallel command starts executing all child command simultaneously. The parallel command is considered finished when all of its child commands have finished. When the parallel command is terminated early, all currently executing commands are terminated.
     * @interface
     */
    interface ParallelCommand {
        'type': 'Parallel';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'commands': Array<interfaces.alexa.presentation.apl.Command>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Plays media on a media player (currently only a Video player; audio may be added in the future). The media may be on the background audio track or may be sequenced with speak directives).
     * @interface
     */
    interface PlayMediaCommand {
        'type': 'PlayMedia';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'audioTrack'?: interfaces.alexa.presentation.apl.AudioTrack;
        'componentId'?: string;
        'source': Array<interfaces.alexa.presentation.apl.VideoSource>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     *
     * @interface
     */
    interface RenderDocumentDirective {
        'type': 'Alexa.Presentation.APL.RenderDocument';
        'token'?: string;
        'document'?: {
            [key: string]: any;
        };
        'datasources'?: {
            [key: string]: any;
        };
        'sources'?: {
            [key: string]: any;
        };
        'packages'?: Array<any>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     *
     * @interface
     */
    interface RotateTransformProperty {
        'rotate'?: number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Notifies the skill of any errors in APL functionality.
     * @interface
     */
    interface RuntimeErrorEvent {
        'type': 'Alexa.Presentation.APL.RuntimeError';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'token': string;
        'errors': Array<interfaces.alexa.presentation.apl.RuntimeError>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     *
     * @interface
     */
    interface ScaleTransformProperty {
        'scale'?: number | string;
        'scaleX'?: number | string;
        'scaleY'?: number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Scroll a ScrollView or Sequence forward or backward by a number of pages. The Scroll command has the following properties in addition to the regular command properties.
     * @interface
     */
    interface ScrollCommand {
        'type': 'Scroll';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'distance'?: number | string;
        'componentId': string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Scroll forward or backward through a ScrollView or Sequence to ensure that a particular component is in view.
     * @interface
     */
    interface ScrollToComponentCommand {
        'type': 'ScrollToComponent';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'align'?: interfaces.alexa.presentation.apl.Align;
        'componentId'?: string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Scroll forward or backward through a ScrollView or Sequence to ensure that a particular child component is in view.
     * @interface
     */
    interface ScrollToIndexCommand {
        'type': 'ScrollToIndex';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'align'?: interfaces.alexa.presentation.apl.Align;
        'componentId': string;
        'index': number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Select a single command from an array of commands and data.
     * @interface
     */
    interface SelectCommand {
        'type': 'Select';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'commands': Array<interfaces.alexa.presentation.apl.Command>;
        'data'?: Array<any>;
        'otherwise'?: Array<interfaces.alexa.presentation.apl.Command>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The SendEvent command allows the APL author to generate and send an event to Alexa.
     * @interface
     */
    interface SendEventCommand {
        'type': 'SendEvent';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'arguments'?: Array<string>;
        'components'?: Array<string>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Returned in response to a LoadIndexListData event, containing the requested items and metadata for further interaction.
     * @interface
     */
    interface SendIndexListDataDirective {
        'type': 'Alexa.Presentation.APL.SendIndexListData';
        'correlationToken'?: string;
        'listId': string;
        'listVersion'?: number;
        'startIndex': number;
        'minimumInclusiveIndex'?: number;
        'maximumExclusiveIndex'?: number;
        'items'?: Array<any>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * A sequential command executes a series of commands in order. The sequential command executes the command list in order, waiting for the previous command to finish before executing the next. The sequential command is finished when all of its child commands have finished. When the Sequential command is terminated early, the currently executing command is terminated and no further commands are executed.
     * @interface
     */
    interface SequentialCommand {
        'type': 'Sequential';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'catch'?: Array<interfaces.alexa.presentation.apl.Command>;
        'commands': Array<interfaces.alexa.presentation.apl.Command>;
        'finally'?: Array<interfaces.alexa.presentation.apl.Command>;
        'repeatCount'?: number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Changes the actionable component that is in focus. Only one component may have focus at a time.
     * @interface
     */
    interface SetFocusCommand {
        'type': 'SetFocus';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'componentId': string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Change the page displayed in a Pager component. The SetPage command finishes when the item is fully in view.
     * @interface
     */
    interface SetPageCommand {
        'type': 'SetPage';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'componentId': string;
        'position'?: interfaces.alexa.presentation.apl.Position;
        'value': number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * The SetState command changes one of the component’s state settings. The SetState command can be used to change the checked, disabled, and focused states. The karaoke and pressed states may not be directly set; use the Select command or SpeakItem commands to change those states. Also, note that the focused state may only be set - it can’t be cleared.
     * @interface
     */
    interface SetStateCommand {
        'type': 'SetState';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'componentId'?: string;
        'state': interfaces.alexa.presentation.apl.ComponentState;
        'value': boolean | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Change a dynamic property of a component without redrawing the screen.
     * @interface
     */
    interface SetValueCommand {
        'type': 'SetValue';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'componentId'?: string;
        'property': string;
        'value': string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     *
     * @interface
     */
    interface SkewTransformProperty {
        'skewX'?: number | string;
        'skewY'?: number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Reads the contents of a single item on the screen. By default the item will be scrolled into view if it is not currently visible.
     * @interface
     */
    interface SpeakItemCommand {
        'type': 'SpeakItem';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'align'?: interfaces.alexa.presentation.apl.Align;
        'componentId': string;
        'highlightMode'?: interfaces.alexa.presentation.apl.HighlightMode;
        'minimumDwellTime'?: number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Read the contents of a range of items inside a common container. Each item will scroll into view before speech. Each item should have a speech property, but it is not required.
     * @interface
     */
    interface SpeakListCommand {
        'type': 'SpeakList';
        'delay'?: number | string;
        'description'?: string;
        'when'?: boolean;
        'align'?: interfaces.alexa.presentation.apl.Align;
        'componentId': string;
        'count': number | string;
        'minimumDwellTime'?: number | string;
        'start': number | string;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     * Updates the content of an dynamicIndexList datasource which has been previously communicated to an Alexa device.
     * @interface
     */
    interface UpdateIndexListDataDirective {
        'type': 'Alexa.Presentation.APL.UpdateIndexListData';
        'token': string;
        'listId': string;
        'listVersion': number;
        'operations': Array<interfaces.alexa.presentation.apl.listoperations.Operation>;
    }
}
export declare namespace interfaces.alexa.presentation.apl {
    /**
     *
     * @interface
     */
    interface UserEvent {
        'type': 'Alexa.Presentation.APL.UserEvent';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'token'?: string;
        'arguments'?: Array<any>;
        'source'?: any;
        'components'?: any;
    }
}
export declare namespace interfaces.alexa.presentation.apl.listoperations {
    /**
     * Deletes an item at a specified index in a dynamicIndexList.
     * @interface
     */
    interface DeleteItemOperation {
        'type': 'DeleteItem';
        'index': number;
    }
}
export declare namespace interfaces.alexa.presentation.apl.listoperations {
    /**
     * Deletes items at consecutive indexes in a dynamicIndexList.
     * @interface
     */
    interface DeleteMultipleItemsOperation {
        'type': 'DeleteMultipleItems';
        'index': number;
        'count': number;
    }
}
export declare namespace interfaces.alexa.presentation.apl.listoperations {
    /**
     * Inserts a new item at a specified index in a dynamicIndexList.
     * @interface
     */
    interface InsertItemOperation {
        'type': 'InsertItem';
        'index': number;
        'item': any;
    }
}
export declare namespace interfaces.alexa.presentation.apl.listoperations {
    /**
     * Inserts an array of items into consecutive indexes in a dynamicIndexList.
     * @interface
     */
    interface InsertMultipleItemsOperation {
        'type': 'InsertMultipleItems';
        'index': number;
        'items': Array<any>;
    }
}
export declare namespace interfaces.alexa.presentation.apl.listoperations {
    /**
     * Sets an item at a specified index in a dynamicIndexList.
     * @interface
     */
    interface SetItemOperation {
        'type': 'SetItem';
        'index': number;
        'item': any;
    }
}
export declare namespace interfaces.alexa.presentation.apla {
    /**
     * This error type occurs when the cloud fails to retrieve an audio file from a remote source, such as one specified from within an Audio component.
     * @interface
     */
    interface AudioSourceRuntimeError {
        'type': 'AUDIO_SOURCE_ERROR';
        'message': string;
        'reason': interfaces.alexa.presentation.apla.AudioSourceErrorReason;
    }
}
export declare namespace interfaces.alexa.presentation.apla {
    /**
     * This error type occurs when the cloud fails to render due to an incorrect or malformed document or data sources.
     * @interface
     */
    interface DocumentRuntimeError {
        'type': 'DOCUMENT_ERROR';
        'message': string;
        'reason': interfaces.alexa.presentation.apla.DocumentErrorReason;
    }
}
export declare namespace interfaces.alexa.presentation.apla {
    /**
     * This error type occurs when the cloud fails to execute a Link typed document.
     * @interface
     */
    interface LinkRuntimeError {
        'type': 'LINK_ERROR';
        'message': string;
        'reason': interfaces.alexa.presentation.apla.LinkErrorReason;
    }
}
export declare namespace interfaces.alexa.presentation.apla {
    /**
     *
     * @interface
     */
    interface RenderDocumentDirective {
        'type': 'Alexa.Presentation.APLA.RenderDocument';
        'token'?: string;
        'document'?: {
            [key: string]: any;
        };
        'datasources'?: {
            [key: string]: any;
        };
    }
}
export declare namespace interfaces.alexa.presentation.apla {
    /**
     * This error type occurs when the the cloud based audio mixing service fails to render the audio due to service or user failure.
     * @interface
     */
    interface RenderRuntimeError {
        'type': 'RENDER_ERROR';
        'message': string;
        'reason': interfaces.alexa.presentation.apla.RenderErrorReason;
    }
}
export declare namespace interfaces.alexa.presentation.apla {
    /**
     * Notifies the skill of any errors in APLA functionality.
     * @interface
     */
    interface RuntimeErrorEvent {
        'type': 'Alexa.Presentation.APLA.RuntimeError';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'token': string;
        'errors': Array<interfaces.alexa.presentation.apla.RuntimeError>;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * Automatically progress through a series of pages displayed in a Pager component. The AutoPage command finishes after the last page has been displayed for the requested time period.
     * @interface
     */
    interface AutoPageCommand {
        'type': 'AutoPage';
        'delay'?: number;
        'description'?: string;
        'screenLock'?: boolean;
        'when'?: boolean | string;
        'componentId': string;
        'count'?: number | string;
        'duration'?: number | string;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * Alexa.Presentation.APLT.ExecuteCommands directive used to send APL-T commands to a device.
     * @interface
     */
    interface ExecuteCommandsDirective {
        'type': 'Alexa.Presentation.APLT.ExecuteCommands';
        'commands': Array<interfaces.alexa.presentation.aplt.Command>;
        'token': string;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * The idle command does nothing. It may be a placeholder or used to insert a calculated delay in a longer series of commands.
     * @interface
     */
    interface IdleCommand {
        'type': 'Idle';
        'delay'?: number;
        'description'?: string;
        'screenLock'?: boolean;
        'when'?: boolean | string;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * Execute a series of commands in parallel. The parallel command starts executing all child command simultaneously. The parallel command is considered finished when all of its child commands have finished. When the parallel command is terminated early, all currently executing commands are terminated.
     * @interface
     */
    interface ParallelCommand {
        'type': 'Parallel';
        'delay'?: number;
        'description'?: string;
        'screenLock'?: boolean;
        'when'?: boolean | string;
        'commands': Array<interfaces.alexa.presentation.aplt.Command>;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     *
     * @interface
     */
    interface RenderDocumentDirective {
        'type': 'Alexa.Presentation.APLT.RenderDocument';
        'token'?: string;
        'targetProfile'?: interfaces.alexa.presentation.aplt.TargetProfile;
        'document'?: {
            [key: string]: any;
        };
        'datasources'?: {
            [key: string]: any;
        };
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * Scroll a ScrollView or Sequence forward or backward by a number of pages. The Scroll command has the following properties in addition to the regular command properties.
     * @interface
     */
    interface ScrollCommand {
        'type': 'Scroll';
        'delay'?: number;
        'description'?: string;
        'screenLock'?: boolean;
        'when'?: boolean | string;
        'distance'?: number | string;
        'componentId': string;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * The SendEvent command allows the APL author to generate and send an event to Alexa.
     * @interface
     */
    interface SendEventCommand {
        'type': 'SendEvent';
        'delay'?: number;
        'description'?: string;
        'screenLock'?: boolean;
        'when'?: boolean | string;
        'arguments'?: Array<string>;
        'components'?: Array<string>;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * A sequential command executes a series of commands in order. The sequential command executes the command list in order, waiting for the previous command to finish before executing the next. The sequential command is finished when all of its child commands have finished. When the Sequential command is terminated early, the currently executing command is terminated and no further commands are executed.
     * @interface
     */
    interface SequentialCommand {
        'type': 'Sequential';
        'delay'?: number;
        'description'?: string;
        'screenLock'?: boolean;
        'when'?: boolean | string;
        'catch'?: Array<interfaces.alexa.presentation.aplt.Command>;
        'commands': Array<interfaces.alexa.presentation.aplt.Command>;
        'finally'?: Array<interfaces.alexa.presentation.aplt.Command>;
        'repeatCount'?: number | string;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * Change the page displayed in a Pager component. The SetPage command finishes when the item is fully in view.
     * @interface
     */
    interface SetPageCommand {
        'type': 'SetPage';
        'delay'?: number;
        'description'?: string;
        'screenLock'?: boolean;
        'when'?: boolean | string;
        'componentId': string;
        'position'?: interfaces.alexa.presentation.aplt.Position;
        'value': number | string;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     * Change a dynamic property of a component without redrawing the screen.
     * @interface
     */
    interface SetValueCommand {
        'type': 'SetValue';
        'delay'?: number;
        'description'?: string;
        'screenLock'?: boolean;
        'when'?: boolean | string;
        'componentId'?: string;
        'property': string;
        'value': string;
    }
}
export declare namespace interfaces.alexa.presentation.aplt {
    /**
     *
     * @interface
     */
    interface UserEvent {
        'type': 'Alexa.Presentation.APLT.UserEvent';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'token'?: string;
        'arguments'?: Array<any>;
        'source'?: any;
    }
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     * The HandleMessage directive sends a message to a skill's web application that runs on the device browser.
     * @interface
     */
    interface HandleMessageDirective {
        'type': 'Alexa.Presentation.HTML.HandleMessage';
        'message': any;
        'transformers'?: Array<interfaces.alexa.presentation.html.Transformer>;
    }
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     * The Message request sends a message to the skill lambda.
     * @interface
     */
    interface MessageRequest {
        'type': 'Alexa.Presentation.HTML.Message';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'message': any;
    }
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     * The RuntimeError request occurs when the device software encounters an error with loading a skill's web application.
     * @interface
     */
    interface RuntimeErrorRequest {
        'type': 'Alexa.Presentation.HTML.RuntimeError';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'error': interfaces.alexa.presentation.html.RuntimeError;
    }
}
export declare namespace interfaces.alexa.presentation.html {
    /**
     * The Start directive provides the data necessary to load an HTML page on the target device.
     * @interface
     */
    interface StartDirective {
        'type': 'Alexa.Presentation.HTML.Start';
        'data'?: any;
        'transformers'?: Array<interfaces.alexa.presentation.html.Transformer>;
        'request': interfaces.alexa.presentation.html.StartRequest;
        'configuration': interfaces.alexa.presentation.html.Configuration;
    }
}
export declare namespace interfaces.amazonpay.model.request {
    /**
     * This is an object to set the attributes specified in the AuthorizeAttributes table. See the “AuthorizationDetails” section of the Amazon Pay API reference guide for details about this object.
     * @interface
     */
    interface AuthorizeAttributes {
        '@type': 'AuthorizeAttributes';
        'authorizationReferenceId': string;
        'authorizationAmount': interfaces.amazonpay.model.request.Price;
        'transactionTimeout'?: number;
        'sellerAuthorizationNote'?: string;
        'softDescriptor'?: string;
        '@version': string;
    }
}
export declare namespace interfaces.amazonpay.model.request {
    /**
     * The merchant can choose to set the attributes specified in the BillingAgreementAttributes.
     * @interface
     */
    interface BillingAgreementAttributes {
        '@type': 'BillingAgreementAttributes';
        'platformId'?: string;
        'sellerNote'?: string;
        'sellerBillingAgreementAttributes'?: interfaces.amazonpay.model.request.SellerBillingAgreementAttributes;
        'billingAgreementType'?: interfaces.amazonpay.model.request.BillingAgreementType;
        'subscriptionAmount'?: interfaces.amazonpay.model.request.Price;
        '@version': string;
    }
}
export declare namespace interfaces.amazonpay.model.request {
    /**
     * This request object specifies amount and currency authorized/captured.
     * @interface
     */
    interface Price {
        '@type': 'Price';
        'amount': string;
        'currencyCode': string;
        '@version': string;
    }
}
export declare namespace interfaces.amazonpay.model.request {
    /**
     * This is required only for Ecommerce provider (Solution provider) use cases.
     * @interface
     */
    interface ProviderAttributes {
        '@type': 'ProviderAttributes';
        'providerId': string;
        'providerCreditList': Array<interfaces.amazonpay.model.request.ProviderCredit>;
        '@version': string;
    }
}
export declare namespace interfaces.amazonpay.model.request {
    /**
     *
     * @interface
     */
    interface ProviderCredit {
        '@type': 'ProviderCredit';
        'providerId'?: string;
        'credit'?: interfaces.amazonpay.model.request.Price;
        '@version': string;
    }
}
export declare namespace interfaces.amazonpay.model.request {
    /**
     * Provides more context about the billing agreement that is represented by this Billing Agreement object.
     * @interface
     */
    interface SellerBillingAgreementAttributes {
        '@type': 'SellerBillingAgreementAttributes';
        'sellerBillingAgreementId'?: string;
        'storeName'?: string;
        'customInformation'?: string;
        '@version': string;
    }
}
export declare namespace interfaces.amazonpay.model.request {
    /**
     * This object includes elements shown to buyers in emails and in their transaction history. See the “SellerOrderAttributes” section of the Amazon Pay API reference guide for details about this object.
     * @interface
     */
    interface SellerOrderAttributes {
        '@type': 'SellerOrderAttributes';
        'sellerOrderId'?: string;
        'storeName'?: string;
        'customInformation'?: string;
        'sellerNote'?: string;
        '@version': string;
    }
}
export declare namespace interfaces.amazonpay.model.response {
    /**
     * This object encapsulates details about an Authorization object including the status, amount captured and fee charged.
     * @interface
     */
    interface AuthorizationDetails {
        'amazonAuthorizationId'?: string;
        'authorizationReferenceId'?: string;
        'sellerAuthorizationNote'?: string;
        'authorizationAmount'?: interfaces.amazonpay.model.response.Price;
        'capturedAmount'?: interfaces.amazonpay.model.response.Price;
        'authorizationFee'?: interfaces.amazonpay.model.response.Price;
        'idList'?: Array<string>;
        'creationTimestamp'?: string;
        'expirationTimestamp'?: string;
        'authorizationStatus'?: interfaces.amazonpay.model.response.AuthorizationStatus;
        'softDecline'?: boolean;
        'captureNow'?: boolean;
        'softDescriptor'?: string;
        'authorizationBillingAddress'?: interfaces.amazonpay.model.response.Destination;
    }
}
export declare namespace interfaces.amazonpay.model.response {
    /**
     * Indicates the current status of an Authorization object, a Capture object, or a Refund object.
     * @interface
     */
    interface AuthorizationStatus {
        'state'?: interfaces.amazonpay.model.response.State;
        'reasonCode'?: string;
        'reasonDescription'?: string;
        'lastUpdateTimestamp'?: string;
    }
}
export declare namespace interfaces.amazonpay.model.response {
    /**
     * The result attributes from successful SetupAmazonPay call.
     * @interface
     */
    interface BillingAgreementDetails {
        'billingAgreementId': string;
        'creationTimestamp'?: string;
        'destination'?: interfaces.amazonpay.model.v1.Destination;
        'checkoutLanguage'?: string;
        'releaseEnvironment': interfaces.amazonpay.model.response.ReleaseEnvironment;
        'billingAgreementStatus': interfaces.amazonpay.model.v1.BillingAgreementStatus;
        'billingAddress'?: interfaces.amazonpay.model.response.Destination;
    }
}
export declare namespace interfaces.amazonpay.model.response {
    /**
     *
     * @interface
     */
    interface Destination {
        'name'?: string;
        'companyName'?: string;
        'addressLine1'?: string;
        'addressLine2'?: string;
        'addressLine3'?: string;
        'city'?: string;
        'districtOrCounty'?: string;
        'stateOrRegion'?: string;
        'postalCode'?: string;
        'countryCode'?: string;
        'phone'?: string;
    }
}
export declare namespace interfaces.amazonpay.model.response {
    /**
     * This response object specifies amount and currency authorized/captured.
     * @interface
     */
    interface Price {
        'amount': string;
        'currencyCode': string;
    }
}
export declare namespace interfaces.amazonpay.request {
    /**
     * Charge Amazon Pay Request Object.
     * @interface
     */
    interface ChargeAmazonPayRequest {
        '@type': 'ChargeAmazonPayRequest';
        '@version': string;
        'sellerId': string;
        'billingAgreementId': string;
        'paymentAction': interfaces.amazonpay.model.request.PaymentAction;
        'authorizeAttributes': interfaces.amazonpay.model.request.AuthorizeAttributes;
        'sellerOrderAttributes'?: interfaces.amazonpay.model.request.SellerOrderAttributes;
        'providerAttributes'?: interfaces.amazonpay.model.request.ProviderAttributes;
    }
}
export declare namespace interfaces.amazonpay.request {
    /**
     * Setup Amazon Pay Request Object.
     * @interface
     */
    interface SetupAmazonPayRequest {
        '@type': 'SetupAmazonPayRequest';
        '@version': string;
        'sellerId': string;
        'countryOfEstablishment': string;
        'ledgerCurrency': string;
        'checkoutLanguage'?: string;
        'billingAgreementAttributes'?: interfaces.amazonpay.model.request.BillingAgreementAttributes;
        'needAmazonShippingAddress'?: boolean;
        'sandboxMode'?: boolean;
        'sandboxCustomerEmailId'?: string;
    }
}
export declare namespace interfaces.amazonpay.response {
    /**
     * Error response for SetupAmazonPay and ChargeAmazonPay calls.
     * @interface
     */
    interface AmazonPayErrorResponse {
        'errorCode': string;
        'errorMessage': string;
    }
}
export declare namespace interfaces.amazonpay.response {
    /**
     * Charge Amazon Pay Result Object. It is sent as part of the response to ChargeAmazonPayRequest.
     * @interface
     */
    interface ChargeAmazonPayResult {
        'amazonOrderReferenceId': string;
        'authorizationDetails': interfaces.amazonpay.model.response.AuthorizationDetails;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface ClearQueueDirective {
        'type': 'AudioPlayer.ClearQueue';
        'clearBehavior'?: interfaces.audioplayer.ClearBehavior;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface PlayDirective {
        'type': 'AudioPlayer.Play';
        'playBehavior'?: interfaces.audioplayer.PlayBehavior;
        'audioItem'?: interfaces.audioplayer.AudioItem;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface PlaybackFailedRequest {
        'type': 'AudioPlayer.PlaybackFailed';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'currentPlaybackState'?: interfaces.audioplayer.CurrentPlaybackState;
        'error'?: interfaces.audioplayer.Error;
        'token'?: string;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface PlaybackFinishedRequest {
        'type': 'AudioPlayer.PlaybackFinished';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'offsetInMilliseconds'?: number;
        'token'?: string;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface PlaybackNearlyFinishedRequest {
        'type': 'AudioPlayer.PlaybackNearlyFinished';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'offsetInMilliseconds'?: number;
        'token'?: string;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface PlaybackStartedRequest {
        'type': 'AudioPlayer.PlaybackStarted';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'offsetInMilliseconds'?: number;
        'token'?: string;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface PlaybackStoppedRequest {
        'type': 'AudioPlayer.PlaybackStopped';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'offsetInMilliseconds'?: number;
        'token'?: string;
    }
}
export declare namespace interfaces.audioplayer {
    /**
     *
     * @interface
     */
    interface StopDirective {
        'type': 'AudioPlayer.Stop';
    }
}
export declare namespace interfaces.connections {
    /**
     * This is the request object that a skill will receive as a result of Connections.SendRequest directive from sender skill.
     * @interface
     */
    interface ConnectionsRequest {
        'type': 'Connections.Request';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'name'?: string;
        'payload'?: {
            [key: string]: any;
        };
    }
}
export declare namespace interfaces.connections {
    /**
     * This is the request object that a skill will receive as a result of Connections.SendResponse directive from referrer skill.
     * @interface
     */
    interface ConnectionsResponse {
        'type': 'Connections.Response';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'status'?: interfaces.connections.ConnectionsStatus;
        'name'?: string;
        'payload'?: {
            [key: string]: any;
        };
        'token'?: string;
    }
}
export declare namespace interfaces.connections {
    /**
     * This is the directive that a skill can send as part of their response to a session based request to execute a predefined Connections. This will also return a result to the referring skill. (No Guarantee response will be returned)
     * @interface
     */
    interface SendRequestDirective {
        'type': 'Connections.SendRequest';
        'name': string;
        'payload'?: {
            [key: string]: any;
        };
        'token': string;
    }
}
export declare namespace interfaces.connections {
    /**
     * This is the directive that a skill can send as part of their response to a session based request to return a response to ConnectionsRequest.
     * @interface
     */
    interface SendResponseDirective {
        'type': 'Connections.SendResponse';
        'status': interfaces.connections.ConnectionsStatus;
        'payload'?: {
            [key: string]: any;
        };
    }
}
export declare namespace interfaces.connections.V1 {
    /**
     * This is the directive that a skill can send as part of their response to a session based request to start a connection. A response will be returned to the skill when the connection is handled.
     * @interface
     */
    interface StartConnectionDirective {
        'type': 'Connections.StartConnection';
        'uri': string;
        'onCompletion'?: interfaces.connections.OnCompletion;
        'input'?: {
            [key: string]: any;
        };
        'token'?: string;
    }
}
export declare namespace interfaces.connections.entities {
    /**
     * Postal Address
     * @interface
     */
    interface PostalAddress {
        '@type': 'PostalAddress';
        '@version': string;
        'streetAddress'?: string;
        'locality'?: string;
        'region'?: string;
        'postalCode'?: string;
        'country'?: string;
    }
}
export declare namespace interfaces.connections.entities {
    /**
     * Restaurant entity
     * @interface
     */
    interface Restaurant {
        '@type': 'Restaurant';
        '@version': string;
        'name': string;
        'location': interfaces.connections.entities.PostalAddress;
    }
}
export declare namespace interfaces.connections.requests {
    /**
     * Payload Request object for PrintImage
     * @interface
     */
    interface PrintImageRequest {
        '@type': 'PrintImageRequest';
        '@version': string;
        'title': string;
        'url': string;
        'description'?: string;
        'imageType': string;
    }
}
export declare namespace interfaces.connections.requests {
    /**
     * Payload Request object for PrintPDF
     * @interface
     */
    interface PrintPDFRequest {
        '@type': 'PrintPDFRequest';
        '@version': string;
        'title': string;
        'url': string;
        'description'?: string;
    }
}
export declare namespace interfaces.connections.requests {
    /**
     * Payload Request object for PrintWebPage
     * @interface
     */
    interface PrintWebPageRequest {
        '@type': 'PrintWebPageRequest';
        '@version': string;
        'title': string;
        'url': string;
        'description'?: string;
    }
}
export declare namespace interfaces.connections.requests {
    /**
     * ScheduleFoodEstablishmentReservationRequest for booking restaurant reservation
     * @interface
     */
    interface ScheduleFoodEstablishmentReservationRequest {
        '@type': 'ScheduleFoodEstablishmentReservationRequest';
        '@version': string;
        'startTime'?: string;
        'partySize'?: string;
        'restaurant': interfaces.connections.entities.Restaurant;
    }
}
export declare namespace interfaces.connections.requests {
    /**
     * ScheduleTaxiReservationRequest for booking taxi reservation
     * @interface
     */
    interface ScheduleTaxiReservationRequest {
        '@type': 'ScheduleTaxiReservationRequest';
        '@version': string;
        'pickupTime'?: string;
        'partySize'?: string;
        'pickupLocation'?: interfaces.connections.entities.PostalAddress;
        'dropOffLocation'?: interfaces.connections.entities.PostalAddress;
    }
}
export declare namespace interfaces.conversations {
    /**
     *
     * @interface
     */
    interface APIInvocationRequest {
        'type': 'Dialog.API.Invoked';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'apiRequest'?: interfaces.conversations.APIRequest;
    }
}
export declare namespace interfaces.customInterfaceController {
    /**
     * Skill receives this type of event when an event meets the filter  conditions provided in the StartEventHandlerDirective.
     * @interface
     */
    interface EventsReceivedRequest {
        'type': 'CustomInterfaceController.EventsReceived';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'token'?: string;
        'events'?: Array<interfaces.customInterfaceController.Event>;
    }
}
export declare namespace interfaces.customInterfaceController {
    /**
     * This is the event received by the skill at expiry of an Event Handler.
     * @interface
     */
    interface ExpiredRequest {
        'type': 'CustomInterfaceController.Expired';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'token'?: string;
        'expirationPayload'?: any;
    }
}
export declare namespace interfaces.customInterfaceController {
    /**
     * The directive to be delivered to the gadgets. Each directive is targeted to one gadget  (that is, one endpointId). To target the same directive to multiple gadgets, include one  directive for each gadget in the response.
     * @interface
     */
    interface SendDirectiveDirective {
        'type': 'CustomInterfaceController.SendDirective';
        'header'?: interfaces.customInterfaceController.Header;
        'payload'?: any;
        'endpoint'?: interfaces.customInterfaceController.Endpoint;
    }
}
export declare namespace interfaces.customInterfaceController {
    /**
     * This directive configures and starts an event handler. This will enable the skill to receive Custom Events. A skill can only have one active Event Handler at a time.
     * @interface
     */
    interface StartEventHandlerDirective {
        'type': 'CustomInterfaceController.StartEventHandler';
        'token'?: string;
        'eventFilter'?: interfaces.customInterfaceController.EventFilter;
        'expiration'?: interfaces.customInterfaceController.Expiration;
    }
}
export declare namespace interfaces.customInterfaceController {
    /**
     * This directive stops a running Event Handler associated with the provided token. The Expiration payload will not be sent if this executed before the Event Handler duration expired.
     * @interface
     */
    interface StopEventHandlerDirective {
        'type': 'CustomInterfaceController.StopEventHandler';
        'token'?: string;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface BodyTemplate1 {
        'type': 'BodyTemplate1';
        'token'?: string;
        'backButton'?: interfaces.display.BackButtonBehavior;
        'backgroundImage'?: interfaces.display.Image;
        'title'?: string;
        'textContent'?: interfaces.display.TextContent;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface BodyTemplate2 {
        'type': 'BodyTemplate2';
        'token'?: string;
        'backButton'?: interfaces.display.BackButtonBehavior;
        'backgroundImage'?: interfaces.display.Image;
        'image'?: interfaces.display.Image;
        'title'?: string;
        'textContent'?: interfaces.display.TextContent;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface BodyTemplate3 {
        'type': 'BodyTemplate3';
        'token'?: string;
        'backButton'?: interfaces.display.BackButtonBehavior;
        'backgroundImage'?: interfaces.display.Image;
        'image'?: interfaces.display.Image;
        'title'?: string;
        'textContent'?: interfaces.display.TextContent;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface BodyTemplate6 {
        'type': 'BodyTemplate6';
        'token'?: string;
        'backButton'?: interfaces.display.BackButtonBehavior;
        'backgroundImage'?: interfaces.display.Image;
        'textContent'?: interfaces.display.TextContent;
        'image'?: interfaces.display.Image;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface BodyTemplate7 {
        'type': 'BodyTemplate7';
        'token'?: string;
        'backButton'?: interfaces.display.BackButtonBehavior;
        'title'?: string;
        'image'?: interfaces.display.Image;
        'backgroundImage'?: interfaces.display.Image;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface ElementSelectedRequest {
        'type': 'Display.ElementSelected';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'token': string;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface HintDirective {
        'type': 'Hint';
        'hint': interfaces.display.Hint;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface ListTemplate1 {
        'type': 'ListTemplate1';
        'token'?: string;
        'backButton'?: interfaces.display.BackButtonBehavior;
        'backgroundImage'?: interfaces.display.Image;
        'title'?: string;
        'listItems'?: Array<interfaces.display.ListItem>;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface ListTemplate2 {
        'type': 'ListTemplate2';
        'token'?: string;
        'backButton'?: interfaces.display.BackButtonBehavior;
        'backgroundImage'?: interfaces.display.Image;
        'title'?: string;
        'listItems'?: Array<interfaces.display.ListItem>;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface PlainText {
        'type': 'PlainText';
        'text': string;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface PlainTextHint {
        'type': 'PlainText';
        'text': string;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface RenderTemplateDirective {
        'type': 'Display.RenderTemplate';
        'template'?: interfaces.display.Template;
    }
}
export declare namespace interfaces.display {
    /**
     *
     * @interface
     */
    interface RichText {
        'type': 'RichText';
        'text': string;
    }
}
export declare namespace interfaces.gadgetController {
    /**
     * Sends Alexa a command to modify the behavior of connected Echo Buttons.
     * @interface
     */
    interface SetLightDirective {
        'type': 'GadgetController.SetLight';
        'version'?: number;
        'targetGadgets'?: Array<string>;
        'parameters'?: services.gadgetController.SetLightParameters;
    }
}
export declare namespace interfaces.gameEngine {
    /**
     * Sent when the conditions of an Echo Button event that your skill defined were met.
     * @interface
     */
    interface InputHandlerEventRequest {
        'type': 'GameEngine.InputHandlerEvent';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'originatingRequestId'?: string;
        'events'?: Array<services.gameEngine.InputHandlerEvent>;
    }
}
export declare namespace interfaces.gameEngine {
    /**
     *
     * @interface
     */
    interface StartInputHandlerDirective {
        'type': 'GameEngine.StartInputHandler';
        'timeout'?: number;
        'proxies'?: Array<string>;
        'recognizers'?: {
            [key: string]: services.gameEngine.Recognizer;
        };
        'events'?: {
            [key: string]: services.gameEngine.Event;
        };
    }
}
export declare namespace interfaces.gameEngine {
    /**
     *
     * @interface
     */
    interface StopInputHandlerDirective {
        'type': 'GameEngine.StopInputHandler';
        'originatingRequestId'?: string;
    }
}
export declare namespace interfaces.messaging {
    /**
     *
     * @interface
     */
    interface MessageReceivedRequest {
        'type': 'Messaging.MessageReceived';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'message': {
            [key: string]: any;
        };
    }
}
export declare namespace interfaces.navigation.assistance {
    /**
     * New directive that Alexa will send to navigation engine to query road regulations about the road segments that the user is on.
     * @interface
     */
    interface AnnounceRoadRegulation {
        'type': 'Navigation.Assistance.AnnounceRoadRegulation';
    }
}
export declare namespace interfaces.playbackcontroller {
    /**
     *
     * @interface
     */
    interface NextCommandIssuedRequest {
        'type': 'PlaybackController.NextCommandIssued';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
    }
}
export declare namespace interfaces.playbackcontroller {
    /**
     *
     * @interface
     */
    interface PauseCommandIssuedRequest {
        'type': 'PlaybackController.PauseCommandIssued';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
    }
}
export declare namespace interfaces.playbackcontroller {
    /**
     *
     * @interface
     */
    interface PlayCommandIssuedRequest {
        'type': 'PlaybackController.PlayCommandIssued';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
    }
}
export declare namespace interfaces.playbackcontroller {
    /**
     *
     * @interface
     */
    interface PreviousCommandIssuedRequest {
        'type': 'PlaybackController.PreviousCommandIssued';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
    }
}
export declare namespace interfaces.system {
    /**
     *
     * @interface
     */
    interface ExceptionEncounteredRequest {
        'type': 'System.ExceptionEncountered';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'error': interfaces.system.Error;
        'cause': interfaces.system.ErrorCause;
    }
}
export declare namespace interfaces.tasks {
    /**
     * This is the directive that a skill can send as part of their response to a session based request. The response will contain the result of the task that the skill is launched for.
     * @interface
     */
    interface CompleteTaskDirective {
        'type': 'Tasks.CompleteTask';
        'status': Status;
        'result'?: {
            [key: string]: any;
        };
    }
}
export declare namespace interfaces.videoapp {
    /**
     *
     * @interface
     */
    interface LaunchDirective {
        'type': 'VideoApp.Launch';
        'videoItem': interfaces.videoapp.VideoItem;
    }
}
export declare namespace interfaces.viewport {
    /**
     * This object contains the characteristics related to the text device's viewport.
     * @interface
     */
    interface APLTViewportState {
        'type': 'APLT';
        'id'?: string;
        'supportedProfiles': Array<interfaces.viewport.aplt.ViewportProfile>;
        'lineLength': number;
        'lineCount': number;
        'characterFormat': interfaces.viewport.aplt.CharacterFormat;
        'interSegments'?: Array<interfaces.viewport.aplt.InterSegment>;
    }
}
export declare namespace interfaces.viewport {
    /**
     * This object contains the characteristics related to the APL device's viewport.
     * @interface
     */
    interface APLViewportState {
        'type': 'APL';
        'id'?: string;
        'shape': interfaces.viewport.Shape;
        'dpi': number;
        'presentationType': interfaces.viewport.PresentationType;
        'canRotate': boolean;
        'configuration': interfaces.viewport.apl.ViewportConfiguration;
    }
}
export declare namespace interfaces.viewport.size {
    /**
     * Defines range of size with minimum and maximum values for with and height.
     * @interface
     */
    interface ContinuousViewportSize {
        'type': 'CONTINUOUS';
        'minPixelWidth': number;
        'minPixelHeight': number;
        'maxPixelWidth': number;
        'maxPixelHeight': number;
    }
}
export declare namespace interfaces.viewport.size {
    /**
     * Defines a fixed size of viewport.
     * @interface
     */
    interface DiscreteViewportSize {
        'type': 'DISCRETE';
        'pixelWidth': number;
        'pixelHeight': number;
    }
}
export declare namespace services.directive {
    /**
     *
     * @interface
     */
    interface SpeakDirective {
        'type': 'VoicePlayer.Speak';
        'speech'?: string;
    }
}
export declare namespace services.gameEngine {
    /**
     * The deviation recognizer returns true when another specified recognizer reports that the player has deviated from its expected pattern.
     * @interface
     */
    interface DeviationRecognizer {
        'type': 'deviation';
        'recognizer'?: string;
    }
}
export declare namespace services.gameEngine {
    /**
     * This recognizer is true when all of the specified events have occurred in the specified order.
     * @interface
     */
    interface PatternRecognizer {
        'type': 'match';
        'anchor'?: services.gameEngine.PatternRecognizerAnchorType;
        'fuzzy'?: boolean;
        'gadgetIds'?: Array<string>;
        'actions'?: Array<string>;
        'pattern'?: Array<services.gameEngine.Pattern>;
    }
}
export declare namespace services.gameEngine {
    /**
     * This recognizer consults another recognizer for the degree of completion, and is true if that degree is above the specified threshold. The completion parameter is specified as a decimal percentage.
     * @interface
     */
    interface ProgressRecognizer {
        'type': 'progress';
        'recognizer'?: string;
        'completion'?: number;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface ListCreatedEventRequest {
        'type': 'AlexaHouseholdListEvent.ListCreated';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: services.listManagement.ListBody;
        'eventCreationTime'?: string;
        'eventPublishingTime'?: string;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface ListDeletedEventRequest {
        'type': 'AlexaHouseholdListEvent.ListDeleted';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: services.listManagement.ListBody;
        'eventCreationTime'?: string;
        'eventPublishingTime'?: string;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface ListItemsCreatedEventRequest {
        'type': 'AlexaHouseholdListEvent.ItemsCreated';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: services.listManagement.ListItemBody;
        'eventCreationTime'?: string;
        'eventPublishingTime'?: string;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface ListItemsDeletedEventRequest {
        'type': 'AlexaHouseholdListEvent.ItemsDeleted';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: services.listManagement.ListItemBody;
        'eventCreationTime'?: string;
        'eventPublishingTime'?: string;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface ListItemsUpdatedEventRequest {
        'type': 'AlexaHouseholdListEvent.ItemsUpdated';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: services.listManagement.ListItemBody;
        'eventCreationTime'?: string;
        'eventPublishingTime'?: string;
    }
}
export declare namespace services.listManagement {
    /**
     *
     * @interface
     */
    interface ListUpdatedEventRequest {
        'type': 'AlexaHouseholdListEvent.ListUpdated';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: services.listManagement.ListBody;
        'eventCreationTime'?: string;
        'eventPublishingTime'?: string;
    }
}
export declare namespace services.reminderManagement {
    /**
     * Response object for get reminder request
     * @interface
     */
    interface GetReminderResponse {
        'alertToken'?: string;
        'createdTime'?: string;
        'updatedTime'?: string;
        'status'?: services.reminderManagement.Status;
        'trigger'?: services.reminderManagement.Trigger;
        'alertInfo'?: services.reminderManagement.AlertInfo;
        'pushNotification'?: services.reminderManagement.PushNotification;
        'version'?: string;
    }
}
export declare namespace services.reminderManagement {
    /**
     *
     * @interface
     */
    interface ReminderCreatedEventRequest {
        'type': 'Reminders.ReminderCreated';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: services.reminderManagement.Event;
    }
}
export declare namespace services.reminderManagement {
    /**
     *
     * @interface
     */
    interface ReminderDeletedEventRequest {
        'type': 'Reminders.ReminderDeleted';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: services.reminderManagement.ReminderDeletedEvent;
    }
}
export declare namespace services.reminderManagement {
    /**
     *
     * @interface
     */
    interface ReminderStartedEventRequest {
        'type': 'Reminders.ReminderStarted';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: services.reminderManagement.Event;
    }
}
export declare namespace services.reminderManagement {
    /**
     *
     * @interface
     */
    interface ReminderStatusChangedEventRequest {
        'type': 'Reminders.ReminderStatusChanged';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: services.reminderManagement.Event;
    }
}
export declare namespace services.reminderManagement {
    /**
     *
     * @interface
     */
    interface ReminderUpdatedEventRequest {
        'type': 'Reminders.ReminderUpdated';
        'requestId': string;
        'timestamp': string;
        'locale'?: string;
        'body'?: services.reminderManagement.Event;
    }
}
export declare namespace services.timerManagement {
    /**
     * ANNOUNCE trigger behavior represents announcing a certain text that the developer wants to be read out at the expiration of the timer.
     * @interface
     */
    interface AnnounceOperation {
        'type': 'ANNOUNCE';
        'textToAnnounce': Array<services.timerManagement.TextToAnnounce>;
    }
}
export declare namespace services.timerManagement {
    /**
     * LAUNCH_TASK trigger behavior representing launch a Skill Connection task exposed by the same skill.
     * @interface
     */
    interface LaunchTaskOperation {
        'type': 'LAUNCH_TASK';
        'textToConfirm': Array<services.timerManagement.TextToConfirm>;
        'task': services.timerManagement.Task;
    }
}
export declare namespace services.timerManagement {
    /**
     * NOTIFY_ONLY trigger behavior represents chime only when timer expired.
     * @interface
     */
    interface NotifyOnlyOperation {
        'type': 'NOTIFY_ONLY';
    }
}
export declare namespace ui {
    /**
     *
     * @interface
     */
    interface AskForPermissionsConsentCard {
        'type': 'AskForPermissionsConsent';
        'permissions': Array<string>;
    }
}
export declare namespace ui {
    /**
     *
     * @interface
     */
    interface LinkAccountCard {
        'type': 'LinkAccount';
    }
}
export declare namespace ui {
    /**
     *
     * @interface
     */
    interface PlainTextOutputSpeech {
        'type': 'PlainText';
        'playBehavior'?: ui.PlayBehavior;
        'text': string;
    }
}
export declare namespace ui {
    /**
     *
     * @interface
     */
    interface SimpleCard {
        'type': 'Simple';
        'title'?: string;
        'content'?: string;
    }
}
export declare namespace ui {
    /**
     *
     * @interface
     */
    interface SsmlOutputSpeech {
        'type': 'SSML';
        'playBehavior'?: ui.PlayBehavior;
        'ssml': string;
    }
}
export declare namespace ui {
    /**
     *
     * @interface
     */
    interface StandardCard {
        'type': 'Standard';
        'title'?: string;
        'text'?: string;
        'image'?: ui.Image;
    }
}
export declare namespace services.deviceAddress {
    /**
     *
     */
    class DeviceAddressServiceClient extends BaseServiceClient {
        private userAgent;
        constructor(apiConfiguration: ApiConfiguration, customUserAgent?: string);
        /**
         *
         * @param {string} deviceId The device Id for which to get the country and postal code
         */
        callGetCountryAndPostalCode(deviceId: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} deviceId The device Id for which to get the country and postal code
         */
        getCountryAndPostalCode(deviceId: string): Promise<services.deviceAddress.ShortAddress>;
        /**
         *
         * @param {string} deviceId The device Id for which to get the address
         */
        callGetFullAddress(deviceId: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} deviceId The device Id for which to get the address
         */
        getFullAddress(deviceId: string): Promise<services.deviceAddress.Address>;
    }
}
export declare namespace services.directive {
    /**
     *
     */
    class DirectiveServiceClient extends BaseServiceClient {
        private userAgent;
        constructor(apiConfiguration: ApiConfiguration, customUserAgent?: string);
        /**
         *
         * @param {services.directive.SendDirectiveRequest} sendDirectiveRequest Represents the request object to send in the payload.
         */
        callEnqueue(sendDirectiveRequest: services.directive.SendDirectiveRequest): Promise<ApiResponse>;
        /**
         *
         * @param {services.directive.SendDirectiveRequest} sendDirectiveRequest Represents the request object to send in the payload.
         */
        enqueue(sendDirectiveRequest: services.directive.SendDirectiveRequest): Promise<void>;
    }
}
export declare namespace services.endpointEnumeration {
    /**
     *
     */
    class EndpointEnumerationServiceClient extends BaseServiceClient {
        private userAgent;
        constructor(apiConfiguration: ApiConfiguration, customUserAgent?: string);
        /**
         *
         */
        callGetEndpoints(): Promise<ApiResponse>;
        /**
         *
         */
        getEndpoints(): Promise<services.endpointEnumeration.EndpointEnumerationResponse>;
    }
}
export declare namespace services.listManagement {
    /**
     *
     */
    class ListManagementServiceClient extends BaseServiceClient {
        private userAgent;
        constructor(apiConfiguration: ApiConfiguration, customUserAgent?: string);
        /**
         *
         */
        callGetListsMetadata(): Promise<ApiResponse>;
        /**
         *
         */
        getListsMetadata(): Promise<services.listManagement.AlexaListsMetadata>;
        /**
         *
         * @param {string} listId Value of the customer’s listId retrieved from a getListsMetadata call
         */
        callDeleteList(listId: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} listId Value of the customer’s listId retrieved from a getListsMetadata call
         */
        deleteList(listId: string): Promise<void>;
        /**
         *
         * @param {string} listId The customer’s listId is retrieved from a getListsMetadata call.
         * @param {string} itemId The customer’s itemId is retrieved from a GetList call.
         */
        callDeleteListItem(listId: string, itemId: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} listId The customer’s listId is retrieved from a getListsMetadata call.
         * @param {string} itemId The customer’s itemId is retrieved from a GetList call.
         */
        deleteListItem(listId: string, itemId: string): Promise<void>;
        /**
         *
         * @param {string} listId Retrieved from a call to getListsMetadata
         * @param {string} itemId itemId within a list is retrieved from a getList call
         */
        callGetListItem(listId: string, itemId: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} listId Retrieved from a call to getListsMetadata
         * @param {string} itemId itemId within a list is retrieved from a getList call
         */
        getListItem(listId: string, itemId: string): Promise<services.listManagement.AlexaListItem>;
        /**
         *
         * @param {string} listId Customer’s listId
         * @param {string} itemId itemId to be updated in the list
         * @param {services.listManagement.UpdateListItemRequest} updateListItemRequest
         */
        callUpdateListItem(listId: string, itemId: string, updateListItemRequest: services.listManagement.UpdateListItemRequest): Promise<ApiResponse>;
        /**
         *
         * @param {string} listId Customer’s listId
         * @param {string} itemId itemId to be updated in the list
         * @param {services.listManagement.UpdateListItemRequest} updateListItemRequest
         */
        updateListItem(listId: string, itemId: string, updateListItemRequest: services.listManagement.UpdateListItemRequest): Promise<services.listManagement.AlexaListItem>;
        /**
         *
         * @param {string} listId The customer’s listId retrieved from a getListsMetadata call.
         * @param {services.listManagement.CreateListItemRequest} createListItemRequest
         */
        callCreateListItem(listId: string, createListItemRequest: services.listManagement.CreateListItemRequest): Promise<ApiResponse>;
        /**
         *
         * @param {string} listId The customer’s listId retrieved from a getListsMetadata call.
         * @param {services.listManagement.CreateListItemRequest} createListItemRequest
         */
        createListItem(listId: string, createListItemRequest: services.listManagement.CreateListItemRequest): Promise<services.listManagement.AlexaListItem>;
        /**
         *
         * @param {string} listId Value of the customer’s listId retrieved from a getListsMetadata call.
         * @param {services.listManagement.UpdateListRequest} updateListRequest
         */
        callUpdateList(listId: string, updateListRequest: services.listManagement.UpdateListRequest): Promise<ApiResponse>;
        /**
         *
         * @param {string} listId Value of the customer’s listId retrieved from a getListsMetadata call.
         * @param {services.listManagement.UpdateListRequest} updateListRequest
         */
        updateList(listId: string, updateListRequest: services.listManagement.UpdateListRequest): Promise<services.listManagement.AlexaListMetadata>;
        /**
         *
         * @param {string} listId Retrieved from a call to GetListsMetadata to specify the listId in the request path.
         * @param {string} status Specify the status of the list.
         */
        callGetList(listId: string, status: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} listId Retrieved from a call to GetListsMetadata to specify the listId in the request path.
         * @param {string} status Specify the status of the list.
         */
        getList(listId: string, status: string): Promise<services.listManagement.AlexaList>;
        /**
         *
         * @param {services.listManagement.CreateListRequest} createListRequest
         */
        callCreateList(createListRequest: services.listManagement.CreateListRequest): Promise<ApiResponse>;
        /**
         *
         * @param {services.listManagement.CreateListRequest} createListRequest
         */
        createList(createListRequest: services.listManagement.CreateListRequest): Promise<services.listManagement.AlexaListMetadata>;
    }
}
export declare namespace services.monetization {
    /**
     *
     */
    class MonetizationServiceClient extends BaseServiceClient {
        private userAgent;
        constructor(apiConfiguration: ApiConfiguration, customUserAgent?: string);
        /**
         *
         * @param {string} acceptLanguage User&#39;s locale/language in context
         * @param {string} purchasable Filter products based on whether they are purchasable by the user or not. * &#39;PURCHASABLE&#39; - Products that are purchasable by the user. * &#39;NOT_PURCHASABLE&#39; - Products that are not purchasable by the user.
         * @param {string} entitled Filter products based on whether they are entitled to the user or not. * &#39;ENTITLED&#39; - Products that the user is entitled to. * &#39;NOT_ENTITLED&#39; - Products that the user is not entitled to.
         * @param {string} productType Product type. * &#39;SUBSCRIPTION&#39; - Once purchased, customers will own the content for the subscription period. * &#39;ENTITLEMENT&#39; - Once purchased, customers will own the content forever. * &#39;CONSUMABLE&#39; - Once purchased, customers will be entitled to the content until it is consumed. It can also be re-purchased.
         * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element, the value of which can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that In-Skill Products API understands. Token has expiry of 24 hours.
         * @param {number} maxResults sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 100 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned because maxResults was exceeded, the response contains isTruncated &#x3D; true.
         */
        callGetInSkillProducts(acceptLanguage: string, purchasable?: string, entitled?: string, productType?: string, nextToken?: string, maxResults?: number): Promise<ApiResponse>;
        /**
         *
         * @param {string} acceptLanguage User&#39;s locale/language in context
         * @param {string} purchasable Filter products based on whether they are purchasable by the user or not. * &#39;PURCHASABLE&#39; - Products that are purchasable by the user. * &#39;NOT_PURCHASABLE&#39; - Products that are not purchasable by the user.
         * @param {string} entitled Filter products based on whether they are entitled to the user or not. * &#39;ENTITLED&#39; - Products that the user is entitled to. * &#39;NOT_ENTITLED&#39; - Products that the user is not entitled to.
         * @param {string} productType Product type. * &#39;SUBSCRIPTION&#39; - Once purchased, customers will own the content for the subscription period. * &#39;ENTITLEMENT&#39; - Once purchased, customers will own the content forever. * &#39;CONSUMABLE&#39; - Once purchased, customers will be entitled to the content until it is consumed. It can also be re-purchased.
         * @param {string} nextToken When response to this API call is truncated (that is, isTruncated response element value is true), the response also includes the nextToken element, the value of which can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that In-Skill Products API understands. Token has expiry of 24 hours.
         * @param {number} maxResults sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 100 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned because maxResults was exceeded, the response contains isTruncated &#x3D; true.
         */
        getInSkillProducts(acceptLanguage: string, purchasable?: string, entitled?: string, productType?: string, nextToken?: string, maxResults?: number): Promise<services.monetization.InSkillProductsResponse>;
        /**
         *
         * @param {string} acceptLanguage User&#39;s locale/language in context
         * @param {string} productId Product Id.
         */
        callGetInSkillProduct(acceptLanguage: string, productId: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} acceptLanguage User&#39;s locale/language in context
         * @param {string} productId Product Id.
         */
        getInSkillProduct(acceptLanguage: string, productId: string): Promise<services.monetization.InSkillProduct>;
        /**
         *
         * @param {string} acceptLanguage User&#39;s locale/language in context
         * @param {string} productId Product Id.
         * @param {string} status Transaction status for in skill product purchases. * &#39;PENDING_APPROVAL_BY_PARENT&#39; - The transaction is pending approval from parent. * &#39;APPROVED_BY_PARENT&#39; - The transaction was approved by parent and fulfilled successfully.. * &#39;DENIED_BY_PARENT&#39; - The transaction was declined by parent and hence not fulfilled. * &#39;EXPIRED_NO_ACTION_BY_PARENT&#39; - The transaction was expired due to no response from parent and hence not fulfilled. * &#39;ERROR&#39; - The transaction was not fullfiled as there was an error while processing the transaction.
         * @param {string} fromLastModifiedTime Filter transactions based on last modified time stamp, FROM duration in format (UTC ISO 8601) i.e. yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;
         * @param {string} toLastModifiedTime Filter transactions based on last modified time stamp, TO duration in format (UTC ISO 8601) i.e. yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;
         * @param {string} nextToken When response to this API call is truncated, the response also includes the nextToken in metadata, the value of which can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that In-Skill Products API understands. Token has expiry of 24 hours.
         * @param {number} maxResults sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 100 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned because maxResults was exceeded, the response contains nextToken which can be used to fetch next set of result.
         */
        callGetInSkillProductsTransactions(acceptLanguage: string, productId?: string, status?: string, fromLastModifiedTime?: string, toLastModifiedTime?: string, nextToken?: string, maxResults?: number): Promise<ApiResponse>;
        /**
         *
         * @param {string} acceptLanguage User&#39;s locale/language in context
         * @param {string} productId Product Id.
         * @param {string} status Transaction status for in skill product purchases. * &#39;PENDING_APPROVAL_BY_PARENT&#39; - The transaction is pending approval from parent. * &#39;APPROVED_BY_PARENT&#39; - The transaction was approved by parent and fulfilled successfully.. * &#39;DENIED_BY_PARENT&#39; - The transaction was declined by parent and hence not fulfilled. * &#39;EXPIRED_NO_ACTION_BY_PARENT&#39; - The transaction was expired due to no response from parent and hence not fulfilled. * &#39;ERROR&#39; - The transaction was not fullfiled as there was an error while processing the transaction.
         * @param {string} fromLastModifiedTime Filter transactions based on last modified time stamp, FROM duration in format (UTC ISO 8601) i.e. yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;
         * @param {string} toLastModifiedTime Filter transactions based on last modified time stamp, TO duration in format (UTC ISO 8601) i.e. yyyy-MM-dd&#39;T&#39;HH:mm:ss.SSS&#39;Z&#39;
         * @param {string} nextToken When response to this API call is truncated, the response also includes the nextToken in metadata, the value of which can be used in the next request as the continuation-token to list the next set of objects. The continuation token is an opaque value that In-Skill Products API understands. Token has expiry of 24 hours.
         * @param {number} maxResults sets the maximum number of results returned in the response body. If you want to retrieve fewer than upper limit of 100 results, you can add this parameter to your request. maxResults should not exceed the upper limit. The response might contain fewer results than maxResults, but it will never contain more. If there are additional results that satisfy the search criteria, but these results were not returned because maxResults was exceeded, the response contains nextToken which can be used to fetch next set of result.
         */
        getInSkillProductsTransactions(acceptLanguage: string, productId?: string, status?: string, fromLastModifiedTime?: string, toLastModifiedTime?: string, nextToken?: string, maxResults?: number): Promise<services.monetization.InSkillProductTransactionsResponse>;
        /**
         *
         */
        callGetVoicePurchaseSetting(): Promise<ApiResponse>;
        /**
         *
         */
        getVoicePurchaseSetting(): Promise<boolean>;
    }
}
export declare namespace services.proactiveEvents {
    /**
     *
     */
    class ProactiveEventsServiceClient extends BaseServiceClient {
        private lwaServiceClient;
        private userAgent;
        constructor(apiConfiguration: ApiConfiguration, authenticationConfiguration: AuthenticationConfiguration, customUserAgent?: string);
        /**
         *
         * @param {services.proactiveEvents.CreateProactiveEventRequest} createProactiveEventRequest Request to create a new proactive event.
         */
        callCreateProactiveEvent(createProactiveEventRequest: services.proactiveEvents.CreateProactiveEventRequest, stage: services.proactiveEvents.SkillStage): Promise<ApiResponse>;
        /**
         *
         * @param {services.proactiveEvents.CreateProactiveEventRequest} createProactiveEventRequest Request to create a new proactive event.
         */
        createProactiveEvent(createProactiveEventRequest: services.proactiveEvents.CreateProactiveEventRequest, stage: services.proactiveEvents.SkillStage): Promise<void>;
    }
}
export declare namespace services.reminderManagement {
    /**
     *
     */
    class ReminderManagementServiceClient extends BaseServiceClient {
        private userAgent;
        constructor(apiConfiguration: ApiConfiguration, customUserAgent?: string);
        /**
         *
         * @param {string} alertToken
         */
        callDeleteReminder(alertToken: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} alertToken
         */
        deleteReminder(alertToken: string): Promise<void>;
        /**
         *
         * @param {string} alertToken
         */
        callGetReminder(alertToken: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} alertToken
         */
        getReminder(alertToken: string): Promise<services.reminderManagement.GetReminderResponse>;
        /**
         *
         * @param {string} alertToken
         * @param {services.reminderManagement.ReminderRequest} reminderRequest
         */
        callUpdateReminder(alertToken: string, reminderRequest: services.reminderManagement.ReminderRequest): Promise<ApiResponse>;
        /**
         *
         * @param {string} alertToken
         * @param {services.reminderManagement.ReminderRequest} reminderRequest
         */
        updateReminder(alertToken: string, reminderRequest: services.reminderManagement.ReminderRequest): Promise<services.reminderManagement.ReminderResponse>;
        /**
         *
         */
        callGetReminders(): Promise<ApiResponse>;
        /**
         *
         */
        getReminders(): Promise<services.reminderManagement.GetRemindersResponse>;
        /**
         *
         * @param {services.reminderManagement.ReminderRequest} reminderRequest
         */
        callCreateReminder(reminderRequest: services.reminderManagement.ReminderRequest): Promise<ApiResponse>;
        /**
         *
         * @param {services.reminderManagement.ReminderRequest} reminderRequest
         */
        createReminder(reminderRequest: services.reminderManagement.ReminderRequest): Promise<services.reminderManagement.ReminderResponse>;
    }
}
export declare namespace services.skillMessaging {
    /**
     *
     */
    class SkillMessagingServiceClient extends BaseServiceClient {
        private lwaServiceClient;
        private userAgent;
        constructor(apiConfiguration: ApiConfiguration, authenticationConfiguration: AuthenticationConfiguration, customUserAgent?: string);
        /**
         *
         * @param {string} userId The user Id for the specific user to send the message
         * @param {services.skillMessaging.SendSkillMessagingRequest} sendSkillMessagingRequest Message Request to be sent to the skill.
         */
        callSendSkillMessage(userId: string, sendSkillMessagingRequest: services.skillMessaging.SendSkillMessagingRequest): Promise<ApiResponse>;
        /**
         *
         * @param {string} userId The user Id for the specific user to send the message
         * @param {services.skillMessaging.SendSkillMessagingRequest} sendSkillMessagingRequest Message Request to be sent to the skill.
         */
        sendSkillMessage(userId: string, sendSkillMessagingRequest: services.skillMessaging.SendSkillMessagingRequest): Promise<void>;
    }
}
export declare namespace services.timerManagement {
    /**
     *
     */
    class TimerManagementServiceClient extends BaseServiceClient {
        private userAgent;
        constructor(apiConfiguration: ApiConfiguration, customUserAgent?: string);
        /**
         *
         */
        callDeleteTimers(): Promise<ApiResponse>;
        /**
         *
         */
        deleteTimers(): Promise<void>;
        /**
         *
         */
        callGetTimers(): Promise<ApiResponse>;
        /**
         *
         */
        getTimers(): Promise<services.timerManagement.TimersResponse>;
        /**
         *
         * @param {string} id
         */
        callDeleteTimer(id: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} id
         */
        deleteTimer(id: string): Promise<void>;
        /**
         *
         * @param {string} id
         */
        callGetTimer(id: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} id
         */
        getTimer(id: string): Promise<services.timerManagement.TimerResponse>;
        /**
         *
         * @param {string} id
         */
        callPauseTimer(id: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} id
         */
        pauseTimer(id: string): Promise<void>;
        /**
         *
         * @param {string} id
         */
        callResumeTimer(id: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} id
         */
        resumeTimer(id: string): Promise<void>;
        /**
         *
         * @param {services.timerManagement.TimerRequest} timerRequest
         */
        callCreateTimer(timerRequest: services.timerManagement.TimerRequest): Promise<ApiResponse>;
        /**
         *
         * @param {services.timerManagement.TimerRequest} timerRequest
         */
        createTimer(timerRequest: services.timerManagement.TimerRequest): Promise<services.timerManagement.TimerResponse>;
    }
}
export declare namespace services.ups {
    /**
     *
     */
    class UpsServiceClient extends BaseServiceClient {
        private userAgent;
        constructor(apiConfiguration: ApiConfiguration, customUserAgent?: string);
        /**
         *
         */
        callGetProfileEmail(): Promise<ApiResponse>;
        /**
         *
         */
        getProfileEmail(): Promise<string>;
        /**
         *
         */
        callGetProfileGivenName(): Promise<ApiResponse>;
        /**
         *
         */
        getProfileGivenName(): Promise<string>;
        /**
         *
         */
        callGetProfileMobileNumber(): Promise<ApiResponse>;
        /**
         *
         */
        getProfileMobileNumber(): Promise<services.ups.PhoneNumber>;
        /**
         *
         */
        callGetProfileName(): Promise<ApiResponse>;
        /**
         *
         */
        getProfileName(): Promise<string>;
        /**
         *
         * @param {string} deviceId The device Id
         */
        callGetSystemDistanceUnits(deviceId: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} deviceId The device Id
         */
        getSystemDistanceUnits(deviceId: string): Promise<services.ups.DistanceUnits>;
        /**
         *
         * @param {string} deviceId The device Id
         */
        callGetSystemTemperatureUnit(deviceId: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} deviceId The device Id
         */
        getSystemTemperatureUnit(deviceId: string): Promise<services.ups.TemperatureUnit>;
        /**
         *
         * @param {string} deviceId The device Id
         */
        callGetSystemTimeZone(deviceId: string): Promise<ApiResponse>;
        /**
         *
         * @param {string} deviceId The device Id
         */
        getSystemTimeZone(deviceId: string): Promise<string>;
        /**
         *
         */
        callGetPersonsProfileGivenName(): Promise<ApiResponse>;
        /**
         *
         */
        getPersonsProfileGivenName(): Promise<string>;
        /**
         *
         */
        callGetPersonsProfileMobileNumber(): Promise<ApiResponse>;
        /**
         *
         */
        getPersonsProfileMobileNumber(): Promise<services.ups.PhoneNumber>;
        /**
         *
         */
        callGetPersonsProfileName(): Promise<ApiResponse>;
        /**
         *
         */
        getPersonsProfileName(): Promise<string>;
    }
}
export declare namespace services {
    /**
     * Helper class that instantiates an ServiceClient implementation automatically resolving its
     * required ApiConfiguration.
     * @export
     * @class ServiceClientFactory
     */
    class ServiceClientFactory {
        protected apiConfiguration: ApiConfiguration;
        constructor(apiConfiguration: ApiConfiguration);
        getDeviceAddressServiceClient(): deviceAddress.DeviceAddressServiceClient;
        getDirectiveServiceClient(): directive.DirectiveServiceClient;
        getEndpointEnumerationServiceClient(): endpointEnumeration.EndpointEnumerationServiceClient;
        getListManagementServiceClient(): listManagement.ListManagementServiceClient;
        getMonetizationServiceClient(): monetization.MonetizationServiceClient;
        getReminderManagementServiceClient(): reminderManagement.ReminderManagementServiceClient;
        getTimerManagementServiceClient(): timerManagement.TimerManagementServiceClient;
        getUpsServiceClient(): ups.UpsServiceClient;
    }
}
